<script setup>
import Chart from '../.vitepress/theme/components/Chart.vue'

const queryAllData = {
  labels: ['Porm', 'Prisma', 'Sequelize', 'Kysely', 'Knex'],
  datasets: [{
    data: [635, 1295, 1156, 787, 826],
    backgroundColor: [
      '#b469ff',
      '#5a67d8',
      '#52b0e7',
      '#ccb765',
      '#c85b24',
    ],
  }]
}

const nestedSelectData = {
  labels: ['Porm', 'Prisma', 'Sequelize'],
  datasets: [{
    data: [726, 1560, 3225],
    backgroundColor: [
      '#b469ff',
      '#5a67d8',
      '#52b0e7',
    ],
  }]
}

const simpleInsertData = {
  labels: ['Porm', 'Prisma', 'Sequelize', 'Kysely', 'Knex'],
  datasets: [{
    data: [896, 1836, 1440, 1158, 1639],
    backgroundColor: [
      '#b469ff',
      '#5a67d8',
      '#52b0e7',
      '#ccb765',
      '#c85b24',
    ],
  }]
}

const nestedInsertData = {
  labels: ['Porm', 'Prisma', 'Sequelize'],
  datasets: [{
    data: [815, 2604, 1605],
    backgroundColor: [
      '#b469ff',
      '#5a67d8',
      '#52b0e7',
    ],
  }]
}
</script>

# Benchmarks

In following benchmarks I'm comparing time elapsed on queries with different ORMs and query builders.

All queries are running sequentially.

Y-axis represents milliseconds - the lower is better.

All tests are done locally on a laptop with Intel Core i7 10 Gen of U-series, Manjaro linux.

All the code with instruction is in the [repo here](https://github.com/romeerez/porm-examples/tree/main/packages/benchmarks).

Tested against `Prisma` and `Sequelize`, which are probably the most popular node.js ORMs.

`kysely` included out of curiosity, it was interesting how it handles more complex cases. Didn't figure out how to make nested select or insert with `kysely` though.

`knex` as well is included for simple cases, but doing nested selects and inserts is too complex with it.

## Load all records from a single table

Measuring a simple query which loads all records from the table with 10 columns, 1000 times.

<Chart :chartData='queryAllData' />

## Load nested relation records

Measuring a query with nested select, query is performed 500 times.

Here is code for `Porm`:

```ts
await db.post
  .select('id', 'title', 'description', {
    author: (q) => q.author.select('id', 'firstName', 'lastName'),
    tags: (q) => q.postTags.pluck('tagName'),
    lastComments: (q) =>
      q.comments
        .select('id', 'text', {
          author: (q) =>
            q.author.select('id', 'firstName', 'lastName'),
        })
        .order({ createdAt: 'DESC' })
        .limit(commentsPerPost),
  })
  .order({ createdAt: 'DESC' });
```

This query is selecting all posts with specific columns, author of post with its columns, post tags, last 3 comments of the post, each comment includes its author's data.

The queries of `Prisma` and `Sequelize` are fetching the same data, except that they don't allow to pick resulting field names like `lastComments`, so the result must be mapped on a JS side.

<Chart :chartData='nestedSelectData' />

## Simple insert

Insert data to a table with 7 columns not counting autogenerated by the database. Run query 1000 times.

All ORMs give more or less consistent numbers, except Prisma: for the first attempt it showed 2.1s, second attempt 1.3s, third attempt 1.8s.

That's a mystery why Knex is slower here than the others.

<Chart :chartData='simpleInsertData' />

## Nested insert

Insert post with comments and with tags, 1000 times.

Sequelize is only inserting posts, because I didn't figure out how it is possible to insert related records all at once.

<Chart :chartData='nestedInsertData' />

## Why Porm performs faster

`Porm` is build with performance in mind, it aims to perform as few queries as possible to load as much as possible.
It does no mapping unless necessary.

`Prisma` is based upon Rust server, communication between node.js and the Rust server is implemented inefficiently,
so it is slower in some benchmarks than the others.

`Sequelize` is generating gigantic inefficient SQL queries when it tries to load relations,
it is slower in tests with selecting relations.

Some ORMs like `Sequelize`, `TypeORM`, `MikroORM` are performing mapping to a class instance:
first data is loaded from db, then they construct class instances with the data.
And when you need to return JSON response to client, need to serialize these class instances to plain objects first.
