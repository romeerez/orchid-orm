import {
  expectSql,
  getDb,
  makeTestUpAndDown,
  queryMock,
  resetDb,
  toLine,
} from '../rake-db.test-utils';
import { asMock, sql } from 'test-utils';

const db = getDb();

const testUpAndDown = async (
  fn: () => Promise<void>,
  expectUp: () => void,
  expectDown: () => void,
) => {
  resetDb(true);
  await fn();
  expectUp();

  resetDb(false);
  await fn();
  expectDown();
};

describe('changeTable', () => {
  it('should interpolate SQL parameters because pg does not support binding params for modifying schema', async () => {
    await db.changeTable('table', (t) => ({
      coL: t.integer().default(sql`1 + ${2}`),
    }));

    expectSql(`
      ALTER TABLE "table"
      ADD COLUMN "co_l" int4 NOT NULL DEFAULT 1 + 2
    `);
  });

  it('should work for table with schema', async () => {
    await testUpAndDown(
      () =>
        db.changeTable('schema.table', (t) => ({
          iD: t.identity().primaryKey(),
        })),
      () =>
        expectSql(`
          ALTER TABLE "schema"."table"
            ADD COLUMN "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
        `),
      () =>
        expectSql(`
          ALTER TABLE "schema"."table"
            DROP COLUMN "i_d"
        `),
    );
  });

  it('should set table comment', async () => {
    await testUpAndDown(
      () => db.changeTable('table', { comment: 'comment' }),
      () => expectSql(`COMMENT ON TABLE "table" IS 'comment'`),
      () => expectSql(`COMMENT ON TABLE "table" IS NULL`),
    );
  });

  it('should change table comment', async () => {
    await testUpAndDown(
      () => db.changeTable('table', { comment: ['old', 'new'] }),
      () => expectSql(`COMMENT ON TABLE "table" IS 'new'`),
      () => expectSql(`COMMENT ON TABLE "table" IS 'old'`),
    );
  });

  describe('add and drop', () => {
    const testUpAndDown = makeTestUpAndDown('add', 'drop');

    describe('column', () => {
      it('should handle primary key column', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              iD: t[action](t.identity().primaryKey()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "i_d"
            `),
        );
      });

      it('should add DEFAULT gen_random_uuid() for uuid primary key', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              iD: t[action](t.uuid().primaryKey()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "i_d" uuid PRIMARY KEY DEFAULT gen_random_uuid()
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "i_d"
            `),
        );
      });

      it('should not add DEFAULT to uuid primary key if user specifies default(null)', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              iD: t[action](t.uuid().primaryKey().default(null)),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "i_d" uuid PRIMARY KEY
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "i_d"
            `),
        );
      });

      it('should not add DEFAULT if the provided default is a function', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              iD: t[action](
                t
                  .uuid()
                  .primaryKey()
                  .default(() => '123'),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "i_d" uuid PRIMARY KEY
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "i_d"
            `),
        );
      });

      it('should add identity column', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              iD: t[action](t.identity().primaryKey()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "i_d"
            `),
        );
      });

      it('should handle column with custom name', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              columnKey: t.name('naMe')[action](t.text()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "naMe" text NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "naMe"
            `),
        );
      });

      it('should handle column with custom name on column itself', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              columnKey: t[action](t.name('naMe').text()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "naMe" text NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "naMe"
            `),
        );
      });

      it('should handle column with drop cascade', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              dropCascade: t[action](t.text(), { dropMode: 'CASCADE' }),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "drop_cascade" text NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "drop_cascade" CASCADE
            `),
        );
      });

      it('should handle nullable column', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              nullAble: t[action](t.text().nullable()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "null_able" text
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "null_able"
            `),
        );
      });

      it('should handle non nullable column', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              nonNullable: t[action](t.text()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "non_nullable" text NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "non_nullable"
            `),
        );
      });

      it('should handle column with default', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              withDefault: t[action](t.boolean().default(false)),
              jsonWithDefault: t[action](t.json().default([])),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "with_default" bool NOT NULL DEFAULT false,
                ADD COLUMN "json_with_default" jsonb NOT NULL DEFAULT '[]'
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "with_default",
                DROP COLUMN "json_with_default"
            `),
        );
      });

      it('should handle column with raw default', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              withDefaultRaw: t[action](t.date().default(t.sql(`now()`))),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "with_default_raw" date NOT NULL DEFAULT now()
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "with_default_raw"
            `),
        );
      });

      it('should handle varchar with length', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              varcharWithLength: t[action](t.varchar(20)),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "varchar_with_length" varchar(20) NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "varchar_with_length"
            `),
        );
      });

      it('should handle decimal with precision and scale', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              decimalWithPrecisionAndScale: t[action](t.decimal(10, 5)),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "decimal_with_precision_and_scale" numeric(10, 5) NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "decimal_with_precision_and_scale"
            `),
        );
      });

      it('should handle column with compression', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              columnWithCompression: t[action](
                t.text().compression('compression'),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "column_with_compression" text COMPRESSION compression NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "column_with_compression"
            `),
        );
      });

      it('should handle column with collate', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              columnWithCollate: t[action](
                t.text().collate('schema.collation'),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "column_with_collate" text COLLATE "schema"."collation" NOT NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "column_with_collate"
            `),
        );
      });

      it('should add and drop the same column with ... syntax', async () => {
        const fn = () =>
          db.changeTable('table', (t) => ({
            ...t.drop(t.name('colUmn').text()),
            ...t.add(t.name('colUmn').integer()),
          }));

        resetDb(true);
        await fn();
        expectSql(`
          ALTER TABLE "table"
            DROP COLUMN "colUmn",
            ADD COLUMN "colUmn" int4 NOT NULL
        `);

        resetDb(false);
        await fn();
        expectSql(`
          ALTER TABLE "table"
            DROP COLUMN "colUmn",
            ADD COLUMN "colUmn" text NOT NULL
        `);
      });
    });

    describe('foreign key', () => {
      it('should handle column with foreign key', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              columnWithForeignKey: t[action](
                t.integer().foreignKey('table', 'colUmn', {
                  name: 'fkeyConstraint',
                  match: 'FULL',
                  onUpdate: 'CASCADE',
                  onDelete: 'CASCADE',
                }),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "column_with_foreign_key" int4 NOT NULL CONSTRAINT "fkeyConstraint" REFERENCES "table"("col_umn") MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "column_with_foreign_key"
            `),
        );
      });
    });

    describe('timestamps', () => {
      it('should handle timestamps', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.timestamps()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "created_at" timestamp with time zone NOT NULL DEFAULT now(),
                ADD COLUMN "updated_at" timestamp with time zone NOT NULL DEFAULT now()
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "created_at",
                DROP COLUMN "updated_at"
            `),
        );
      });
    });

    describe('index', () => {
      it('should handle index', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              withIndex: t[action](
                // @ts-expect-error name as argument is deprecated
                t.text().unique('indexName', {
                  nullsNotDistinct: true,
                  using: 'gin',
                  collate: 'schema.collation',
                  opclass: 'opclass',
                  order: 'ASC',
                  include: 'iD',
                  with: 'fillfactor = 70',
                  tablespace: 'tablespace',
                  where: 'column = 123',
                  expression: 'index expression',
                }),
              ),
              withIndex2: t[action](
                t.text().unique({
                  name: 'indexName',
                  nullsNotDistinct: true,
                  using: 'gin',
                  collate: 'schema.collation',
                  opclass: 'opclass',
                  order: 'ASC',
                  include: 'iD',
                  with: 'fillfactor = 70',
                  tablespace: 'tablespace',
                  where: 'column = 123',
                  expression: 'index expression',
                }),
              ),
            })),
          () =>
            expectSql([
              `ALTER TABLE "table"
                ADD COLUMN "with_index" text NOT NULL,
                ADD COLUMN "with_index2" text NOT NULL`,
              toLine(`
                CREATE UNIQUE INDEX "indexName"
                  ON "table"
                  USING gin ((index expression) COLLATE "schema"."collation" opclass ASC)
                  INCLUDE ("i_d")
                  NULLS NOT DISTINCT
                  WITH (fillfactor = 70)
                  TABLESPACE tablespace
                  WHERE column = 123
              `),
              toLine(`
                CREATE UNIQUE INDEX "indexName"
                  ON "table"
                  USING gin ((index expression) COLLATE "schema"."collation" opclass ASC)
                  INCLUDE ("i_d")
                  NULLS NOT DISTINCT
                  WITH (fillfactor = 70)
                  TABLESPACE tablespace
                  WHERE column = 123
              `),
            ]),
          () =>
            expectSql([
              `ALTER TABLE "table"
                DROP COLUMN "with_index",
                DROP COLUMN "with_index2"`,
              // index is dropped automatically with the column
            ]),
        );
      });

      it('should handle unique index', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              uniqueColumn: t[action](
                t
                  .text()
                  .unique({ dropMode: 'CASCADE', nullsNotDistinct: true }),
              ),
            })),
          () =>
            expectSql([
              `ALTER TABLE "table"
              ADD COLUMN "unique_column" text NOT NULL`,
              toLine(`
            CREATE UNIQUE INDEX "table_unique_column_idx"
              ON "table" ("unique_column") NULLS NOT DISTINCT
          `),
            ]),
          () =>
            expectSql([
              `ALTER TABLE "table"
              DROP COLUMN "unique_column"`,
            ]),
        );
      });
    });

    describe('exclude', () => {
      it('should handle exclude', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              withExclude: t[action](
                // @ts-expect-error name as argument is deprecated
                t.text().exclude('&&', 'excludeName', {
                  using: 'GIST',
                  collate: 'col',
                  opclass: 'opc',
                  order: 'ASC',
                  include: 'inc',
                  with: 'wit',
                  tablespace: 'tbs',
                  where: 'whe',
                }),
              ),
              withExclude2: t[action](
                t.text().exclude('&&', {
                  name: 'excludeName',
                  using: 'GIST',
                  collate: 'col',
                  opclass: 'opc',
                  order: 'ASC',
                  include: 'inc',
                  with: 'wit',
                  tablespace: 'tbs',
                  where: 'whe',
                }),
              ),
            })),
          () =>
            expectSql([
              `ALTER TABLE "table"
                ADD COLUMN "with_exclude" text NOT NULL,
                ADD COLUMN "with_exclude2" text NOT NULL`,
              toLine(`
                ALTER TABLE "table"
                ADD CONSTRAINT "excludeName"
                EXCLUDE USING GIST ("with_exclude" COLLATE "col" opc ASC WITH &&)
                INCLUDE ("inc")
                WITH (wit)
                USING INDEX TABLESPACE tbs
                WHERE whe
              `),
              toLine(`
                ALTER TABLE "table"
                ADD CONSTRAINT "excludeName"
                EXCLUDE USING GIST ("with_exclude2" COLLATE "col" opc ASC WITH &&)
                INCLUDE ("inc")
                WITH (wit)
                USING INDEX TABLESPACE tbs
                WHERE whe
              `),
            ]),
          () =>
            expectSql([
              `ALTER TABLE "table"
                DROP COLUMN "with_exclude",
                DROP COLUMN "with_exclude2"`,
            ]),
        );
      });
    });

    describe('column comment', () => {
      it('should handle column comment', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              columnWithComment: t[action](
                t.text().comment('this is a column comment'),
              ),
            })),
          () =>
            expectSql([
              `ALTER TABLE "table"
            ADD COLUMN "column_with_comment" text NOT NULL`,
              `COMMENT ON COLUMN "table"."column_with_comment" IS 'this is a column comment'`,
            ]),
          () =>
            expectSql(
              `ALTER TABLE "table"
            DROP COLUMN "column_with_comment"`,
            ),
        );
      });
    });

    it('should handle enum', async () => {
      await testUpAndDown(
        async (action) => {
          asMock(queryMock).mockResolvedValue({ rows: [['one'], ['two']] });

          await db.changeTable('table', (t) => ({
            enUm: t[action](t.enum('mood')),
          }));
        },
        () => {
          expectSql([
            'SELECT unnest(enum_range(NULL::"mood"))::text',
            `
              ALTER TABLE "table"
                ADD COLUMN "en_um" "mood" NOT NULL
            `,
          ]);
        },
        () => {
          expectSql([
            'SELECT unnest(enum_range(NULL::"mood"))::text',
            `
              ALTER TABLE "table"
                DROP COLUMN "en_um"
            `,
          ]);
        },
      );
    });

    it('should handle custom column type', async () => {
      await testUpAndDown(
        (action) =>
          db.changeTable('table', (t) => ({
            colUmn: t[action](t.type('schema.type')),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ADD COLUMN "col_umn" "schema".type NOT NULL
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              DROP COLUMN "col_umn"
          `),
      );
    });

    it('should handle domain column', async () => {
      await testUpAndDown(
        (action) =>
          db.changeTable('table', (t) => ({
            colUmn: t[action](t.domain('domainName')),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ADD COLUMN "col_umn" "domainName" NOT NULL
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              DROP COLUMN "col_umn"
          `),
      );
    });

    describe('primary key', () => {
      it('should handle columns with a primary key', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              iD: t[action](t.integer().primaryKey()),
              teXt: t[action](t.text().primaryKey()),
              actIve: t[action](t.boolean().primaryKey()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ADD COLUMN "i_d" int4 NOT NULL,
              ADD COLUMN "te_xt" text NOT NULL,
              ADD COLUMN "act_ive" bool NOT NULL,
              ADD PRIMARY KEY ("i_d", "te_xt", "act_ive")
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "table_pkey",
              DROP COLUMN "i_d",
              DROP COLUMN "te_xt",
              DROP COLUMN "act_ive"
            `),
        );
      });

      it('should handle composite primary key', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.primaryKey(['iD', 'naMe'])),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ADD PRIMARY KEY ("i_d", "na_me")
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "table_pkey"
            `),
        );
      });

      it('should handle composite primary key with constraint name', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.primaryKey(['iD', 'naMe'], 'primaryKeyName')),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ADD CONSTRAINT "primaryKeyName" PRIMARY KEY ("i_d", "na_me")
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "primaryKeyName"
            `),
        );
      });

      it('should should strip duplicated primary key columns', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              aA: t[action](t.integer().primaryKey()),
              bB: t[action](t.text().primaryKey()),
              ...t[action](t.primaryKey(['aA', 'bB'])),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ADD COLUMN "a_a" int4 NOT NULL,
              ADD COLUMN "b_b" text NOT NULL,
              ADD PRIMARY KEY ("a_a", "b_b")
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "table_pkey",
              DROP COLUMN "a_a",
              DROP COLUMN "b_b"
            `),
        );
      });
    });

    describe('index', () => {
      it('should handle composite index', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](
                t.index(
                  ['iD', { column: 'naMe', order: 'DESC' }],
                  'compositeIndexOnTable',
                  // @ts-expect-error name as argument is deprecated
                  {
                    dropMode: 'CASCADE',
                  },
                ),
              ),
              ...t[action](
                t.index(['iD', { column: 'naMe', order: 'DESC' }], {
                  name: 'compositeIndexOnTable',
                  dropMode: 'CASCADE',
                }),
              ),
            })),
          () =>
            expectSql([
              `
                CREATE INDEX "compositeIndexOnTable" ON "table" ("i_d", "na_me" DESC)
              `,
              `
                CREATE INDEX "compositeIndexOnTable" ON "table" ("i_d", "na_me" DESC)
              `,
            ]),
          () =>
            expectSql([
              `
                DROP INDEX "compositeIndexOnTable" CASCADE
              `,
              `
                DROP INDEX "compositeIndexOnTable" CASCADE
              `,
            ]),
        );
      });

      it('should handle composite unique index', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](
                t.unique(
                  ['iD', { column: 'naMe', order: 'DESC' }],
                  'compositeIndexOnTable',
                  // @ts-expect-error name as argument is deprecated
                  {
                    nullsNotDistinct: true,
                    dropMode: 'CASCADE',
                  },
                ),
              ),
              ...t[action](
                t.unique(['iD', { column: 'naMe', order: 'DESC' }], {
                  name: 'compositeIndexOnTable',
                  nullsNotDistinct: true,
                  dropMode: 'CASCADE',
                }),
              ),
            })),
          () =>
            expectSql([
              toLine(`
                CREATE UNIQUE INDEX "compositeIndexOnTable"
                  ON "table" ("i_d", "na_me" DESC) NULLS NOT DISTINCT
              `),
              toLine(`
                CREATE UNIQUE INDEX "compositeIndexOnTable"
                  ON "table" ("i_d", "na_me" DESC) NULLS NOT DISTINCT
              `),
            ]),
          () =>
            expectSql([
              `
                DROP INDEX "compositeIndexOnTable" CASCADE
              `,
              `
                DROP INDEX "compositeIndexOnTable" CASCADE
              `,
            ]),
        );
      });
    });

    describe('search index', () => {
      beforeEach(() => {
        delete db.options.language;
      });

      it('should add a search index for a single column', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.searchIndex(['teXt'])),
            })),
          () =>
            expectSql(`
              CREATE INDEX "table_te_xt_idx" ON "table" USING gin (to_tsvector('english', "te_xt"))
            `),
          () =>
            expectSql(`
              DROP INDEX "table_te_xt_idx"
            `),
        );
      });

      it('should handle an index for search with english by default', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.searchIndex(['titLe', 'teXt'])),
            })),
          () =>
            expectSql(`
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('english', "tit_le" || ' ' || "te_xt"))
            `),
          () =>
            expectSql(`
              DROP INDEX "table_tit_le_te_xt_idx"
            `),
        );
      });

      it('should handle an index for search with a custom default language', async () => {
        db.options.language = 'Ukrainian';

        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.searchIndex(['titLe', 'teXt'])),
            })),
          () =>
            expectSql(`
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('Ukrainian', "tit_le" || ' ' || "te_xt"))
            `),
          () =>
            expectSql(`
              DROP INDEX "table_tit_le_te_xt_idx"
            `),
        );
      });

      it('should support an index for search with a custom default language set in the table options', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', { language: 'Ukrainian' }, (t) => ({
              ...t[action](t.searchIndex(['titLe', 'teXt'])),
            })),
          () =>
            expectSql(`
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('Ukrainian', "tit_le" || ' ' || "te_xt"))
            `),
          () =>
            expectSql(`
              DROP INDEX "table_tit_le_te_xt_idx"
            `),
        );
      });

      it('should support an index for search with a custom default language set in the index options', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](
                t.searchIndex(['titLe', 'teXt'], { language: 'Ukrainian' }),
              ),
            })),
          () =>
            expectSql(`
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('Ukrainian', "tit_le" || ' ' || "te_xt"))
            `),
          () =>
            expectSql(`
              DROP INDEX "table_tit_le_te_xt_idx"
            `),
        );
      });

      it('should use a language from a column', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](
                t.searchIndex(['titLe', 'teXt'], { languageColumn: 'lang' }),
              ),
            })),
          () =>
            expectSql(`
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector("lang", "tit_le" || ' ' || "te_xt"))
            `),
          () =>
            expectSql(`
              DROP INDEX "table_tit_le_te_xt_idx"
            `),
        );
      });

      it('should set weights on columns', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](
                t.searchIndex([
                  { column: 'titLe', weight: 'A' },
                  { column: 'teXt', weight: 'B' },
                ]),
              ),
            })),
          () =>
            expectSql(
              toLine(`
                CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin
                  ((setweight(to_tsvector('english', coalesce("tit_le", '')), 'A') ||
                   setweight(to_tsvector('english', coalesce("te_xt", '')), 'B')))
              `),
            ),
          () =>
            expectSql(`
              DROP INDEX "table_tit_le_te_xt_idx"
            `),
        );
      });

      it('should index a generated column', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              generAted: t[action](
                t.tsvector().generated(['titLe', 'teXt']).searchIndex(),
              ),
            })),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                ADD COLUMN "gener_ated" tsvector GENERATED ALWAYS AS (to_tsvector('english', coalesce("tit_le", '') || ' ' || coalesce("te_xt", ''))) STORED NOT NULL
              `,
              `
                CREATE INDEX "table_gener_ated_idx" ON "table" USING GIN ("gener_ated")
              `,
            ]),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                DROP COLUMN "gener_ated"
              `,
            ]),
        );
      });

      it('should index a generated column with weights', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              generAted: t[action](
                t.tsvector().generated({ titLe: 'A', teXt: 'B' }).searchIndex(),
              ),
            })),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                ADD COLUMN "gener_ated" tsvector GENERATED ALWAYS AS ((setweight(to_tsvector('english', coalesce("tit_le", '')), 'A') || setweight(to_tsvector('english', coalesce("te_xt", '')), 'B'))) STORED NOT NULL
              `,
              `
                CREATE INDEX "table_gener_ated_idx" ON "table" USING GIN ("gener_ated")
              `,
            ]),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                DROP COLUMN "gener_ated"
              `,
            ]),
        );
      });

      it('should index a generated column with a configured default language', async () => {
        db.options.language = 'Ukrainian';

        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              generAted: t[action](
                t.tsvector().generated(['titLe', 'teXt']).searchIndex(),
              ),
            })),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                ADD COLUMN "gener_ated" tsvector GENERATED ALWAYS AS (to_tsvector('Ukrainian', coalesce("tit_le", '') || ' ' || coalesce("te_xt", ''))) STORED NOT NULL
              `,
              `
                CREATE INDEX "table_gener_ated_idx" ON "table" USING GIN ("gener_ated")
              `,
            ]),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                DROP COLUMN "gener_ated"
              `,
            ]),
        );
      });

      it('should index a generated column with a custom default language', async () => {
        db.options.language = 'Ukrainian';

        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              generAted: t[action](
                t
                  .tsvector()
                  .generated('Ukrainian', ['titLe', 'teXt'])
                  .searchIndex(),
              ),
            })),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                ADD COLUMN "gener_ated" tsvector GENERATED ALWAYS AS (to_tsvector('Ukrainian', coalesce("tit_le", '') || ' ' || coalesce("te_xt", ''))) STORED NOT NULL
              `,
              `
                CREATE INDEX "table_gener_ated_idx" ON "table" USING GIN ("gener_ated")
              `,
            ]),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                DROP COLUMN "gener_ated"
              `,
            ]),
        );
      });
    });

    describe('composite exclude', () => {
      it('should handle composite exclude', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](
                t.exclude(
                  [
                    {
                      column: 'iD',
                      with: '=',
                      collate: 'col',
                      opclass: 'opc',
                      order: 'ASC',
                    },
                    { expression: 'expr', with: '&&' },
                  ],
                  'excludeName',
                  // @ts-expect-error name as argument is deprecated
                  {
                    using: 'GIST',
                    include: 'inc',
                    with: 'wit',
                    tablespace: 'tbs',
                    where: 'whe',
                    dropMode: 'CASCADE',
                  },
                ),
              ),
              ...t[action](
                t.exclude(
                  [
                    {
                      column: 'iD',
                      with: '=',
                      collate: 'col',
                      opclass: 'opc',
                      order: 'ASC',
                    },
                    { expression: 'expr', with: '&&' },
                  ],
                  {
                    name: 'excludeName',
                    using: 'GIST',
                    include: 'inc',
                    with: 'wit',
                    tablespace: 'tbs',
                    where: 'whe',
                    dropMode: 'CASCADE',
                  },
                ),
              ),
            })),
          () =>
            expectSql([
              toLine(`ALTER TABLE "table"
                ADD CONSTRAINT "excludeName"
                EXCLUDE USING GIST ("i_d" COLLATE "col" opc ASC WITH =, (expr) WITH &&)
                INCLUDE ("inc")
                WITH (wit)
                USING INDEX TABLESPACE tbs
                WHERE whe`),
              toLine(`ALTER TABLE "table"
                ADD CONSTRAINT "excludeName"
                EXCLUDE USING GIST ("i_d" COLLATE "col" opc ASC WITH =, (expr) WITH &&)
                INCLUDE ("inc")
                WITH (wit)
                USING INDEX TABLESPACE tbs
                WHERE whe`),
            ]),
          () =>
            expectSql([
              `ALTER TABLE "table" DROP CONSTRAINT "excludeName" CASCADE`,
              `ALTER TABLE "table" DROP CONSTRAINT "excludeName" CASCADE`,
            ]),
        );
      });
    });

    describe('foreign key', () => {
      it('should handle composite foreign key', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](
                t.foreignKey(
                  ['iD', 'naMe'],
                  'otherTable',
                  ['foreignId', 'foreignName'],
                  {
                    name: 'constraintName',
                    match: 'FULL',
                    onUpdate: 'CASCADE',
                    onDelete: 'CASCADE',
                    dropMode: 'CASCADE',
                  },
                ),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ${toLine(`
                ADD CONSTRAINT "constraintName"
                  FOREIGN KEY ("i_d", "na_me")
                  REFERENCES "otherTable"("foreign_id", "foreign_name")
                  MATCH FULL
                  ON DELETE CASCADE
                  ON UPDATE CASCADE
              `)}
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "constraintName" CASCADE
            `),
        );
      });
    });

    describe('check', () => {
      it('should handle column with check', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              colUmn: t[action](t.text().check(t.sql(`length(col_umn) > 10`))),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "col_umn" text NOT NULL CHECK (length(col_umn) > 10)
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "col_umn"
            `),
        );
      });

      it('should handle named column checks', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              colUmn: t[action](
                t
                  .text()
                  .check(t.sql(`length(col_umn) > 10`), 'gt10')
                  .check(t.sql(`length(col_umn) < 20`), 'lt20'),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD COLUMN "col_umn" text NOT NULL CONSTRAINT "gt10" CHECK (length(col_umn) > 10), CONSTRAINT "lt20" CHECK (length(col_umn) < 20)
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP COLUMN "col_umn"
            `),
        );
      });

      it('should handle table check', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.check(t.sql('sql'))),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD CONSTRAINT "table_check" CHECK (sql)
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "table_check"
            `),
        );
      });

      it('should handle named table check', async () => {
        await testUpAndDown(
          (action) =>
            db.changeTable('table', (t) => ({
              ...t[action](t.check(t.sql('sql'), 'name')),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD CONSTRAINT "name" CHECK (sql)
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "name"
            `),
        );
      });
    });
  });

  describe('change', () => {
    describe('type', () => {
      it('should change column type', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeType: t.change(t.integer(), t.text()),
              changeDomainType: t.change(t.domain('one'), t.domain('two')),
              changeCustomType: t.change(t.type('one'), t.type('two')),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ALTER COLUMN "change_type" TYPE text,
                ALTER COLUMN "change_domain_type" TYPE "two",
                ALTER COLUMN "change_custom_type" TYPE two
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ALTER COLUMN "change_type" TYPE int4,
                ALTER COLUMN "change_domain_type" TYPE "one",
                ALTER COLUMN "change_custom_type" TYPE one
            `),
        );
      });

      it('should change column type with custom name', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              naMe: t.name('name').change(t.integer(), t.text()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ALTER COLUMN "name" TYPE text
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ALTER COLUMN "name" TYPE int4
            `),
        );
      });

      it('should change column type using', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeTypeUsing: t.change(t.integer(), t.text(), {
                usingUp: t.sql`b::text`,
                usingDown: t.sql`b::int`,
              }),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ALTER COLUMN "change_type_using" TYPE text USING b::text
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ALTER COLUMN "change_type_using" TYPE int4 USING b::int
            `),
        );
      });
    });

    it('should add identity to a column', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            iD: t.change(t.integer(), t.identity()),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "i_d" ADD GENERATED BY DEFAULT AS IDENTITY
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "i_d" DROP IDENTITY
          `),
      );
    });

    it('should change identity properties', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            iD: t.change(
              t.identity(),
              t.identity({
                increment: 2,
                start: 3,
                min: 4,
                max: 5,
                cache: 6,
                cycle: true,
              }),
            ),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "i_d" DROP IDENTITY,
              ALTER COLUMN "i_d" ADD GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 2 MINVALUE 4 MAXVALUE 5 START WITH 3 CACHE 6 CYCLE)
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "i_d" DROP IDENTITY,
              ALTER COLUMN "i_d" ADD GENERATED BY DEFAULT AS IDENTITY
          `),
      );
    });

    it('should change enum column', async () => {
      const enumOne = ['one', 'two'];
      const enumTwo = ['three', 'four'];

      asMock(queryMock).mockResolvedValueOnce({
        rows: enumOne.map((value) => [value]),
      });
      asMock(queryMock).mockResolvedValueOnce({
        rows: enumTwo.map((value) => [value]),
      });

      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            changeEnum: t.change(t.enum('one'), t.enum('two')),
            changeEnumArr: t.change(
              t.array(t.enum('one')),
              t.array(t.enum('two')),
            ),
          })),
        () => {
          expectSql([
            'SELECT unnest(enum_range(NULL::"one"))::text',
            'SELECT unnest(enum_range(NULL::"two"))::text',
            `
            ALTER TABLE "table"
              ALTER COLUMN "change_enum" TYPE "two" USING "change_enum"::text::"two",
              ALTER COLUMN "change_enum_arr" TYPE "two"[] USING "change_enum_arr"::text[]::"two"[]
            `,
          ]);

          asMock(queryMock).mockResolvedValueOnce({
            rows: enumTwo.map((value) => [value]),
          });
          asMock(queryMock).mockResolvedValueOnce({
            rows: enumOne.map((value) => [value]),
          });
        },
        () => {
          expectSql([
            'SELECT unnest(enum_range(NULL::"two"))::text',
            'SELECT unnest(enum_range(NULL::"one"))::text',
            `
            ALTER TABLE "table"
              ALTER COLUMN "change_enum" TYPE "one" USING "change_enum"::text::"one",
              ALTER COLUMN "change_enum_arr" TYPE "one"[] USING "change_enum_arr"::text[]::"one"[]
          `,
          ]);
        },
      );
    });

    describe('check', () => {
      it('should change column checks', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              colUmn: t.change(
                t
                  .text()
                  .check(t.sql`length(col_umn) < 20`)
                  .check(t.sql`length(col_umn) < 30`),
                t
                  .text()
                  .check(t.sql`length(col_umn) > 10`)
                  .check(t.sql`length(col_umn) > 0`),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "table_col_umn_check",
                DROP CONSTRAINT "table_col_umn_check1",
                ADD CONSTRAINT "table_col_umn_check"
                  CHECK (length(col_umn) > 10),
                ADD CONSTRAINT "table_col_umn_check1"
                  CHECK (length(col_umn) > 0)
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "table_col_umn_check",
                DROP CONSTRAINT "table_col_umn_check1",
                ADD CONSTRAINT "table_col_umn_check"
                  CHECK (length(col_umn) < 20),
                ADD CONSTRAINT "table_col_umn_check1"
                  CHECK (length(col_umn) < 30)
            `),
        );
      });
    });

    it('should change column collate', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            changeCollate: t.change(
              t.text().collate('one.two'),
              t.text().collate('three.four'),
            ),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_collate" TYPE text COLLATE "three"."four"
        `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_collate" TYPE text COLLATE "one"."two"
        `),
      );
    });

    describe('change default', () => {
      it('should change column default', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeDefault: t.change(
                t.default('from'),
                t.default(t.sql("'to'")),
              ),
              changeJsonDefault: t.change(
                t.json().default(null),
                t.json().default([]),
              ),
            })),
          () =>
            expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_default" SET DEFAULT 'to',
              ALTER COLUMN "change_json_default" SET DEFAULT '[]'
          `),
          () =>
            expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_default" SET DEFAULT 'from',
              ALTER COLUMN "change_json_default" DROP DEFAULT
          `),
        );
      });

      it('should change column default with custom name', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeDefault: t
                .name('name')
                .change(t.default('from'), t.default(t.sql("'to'"))),
            })),
          () =>
            expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "name" SET DEFAULT 'to'
          `),
          () =>
            expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "name" SET DEFAULT 'from'
          `),
        );
      });

      it('should drop column default when changing column type before setting new default', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              colUmn: t.change(
                t.string().default('default'),
                t.integer().default(123),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ALTER COLUMN "col_umn" TYPE int4,
              ALTER COLUMN "col_umn" DROP DEFAULT,
              ALTER COLUMN "col_umn" SET DEFAULT 123
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ALTER COLUMN "col_umn" TYPE varchar(255),
              ALTER COLUMN "col_umn" DROP DEFAULT,
              ALTER COLUMN "col_umn" SET DEFAULT 'default'
            `),
        );
      });

      it('should change the default from null', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              colUmn: t.change(t.default(null), t.default(123)),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ALTER COLUMN "col_umn" SET DEFAULT 123
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ALTER COLUMN "col_umn" DROP DEFAULT
            `),
        );
      });

      it('should drop uuid default', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              colUmn: t.change(
                t.uuid().primaryKey(),
                t.uuid().primaryKey().default(null),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ALTER COLUMN "col_umn" DROP DEFAULT
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ALTER COLUMN "col_umn" SET DEFAULT gen_random_uuid()
            `),
        );
      });
    });

    it('should change column null', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            changeNull: t.change(t.nonNullable(), t.nullable()),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_null" DROP NOT NULL
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_null" SET NOT NULL
          `),
      );
    });

    it('should change column null with custom column name', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            changeNull: t.name('name').change(t.nonNullable(), t.nullable()),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "name" DROP NOT NULL
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "name" SET NOT NULL
          `),
      );
    });

    describe('comment', () => {
      it('should change column comment', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeComment: t.change(
                t.comment('comment 1'),
                t.comment('comment 2'),
              ),
            })),
          () =>
            expectSql(`
            COMMENT ON COLUMN "table"."change_comment" IS 'comment 2'
          `),
          () =>
            expectSql(`
            COMMENT ON COLUMN "table"."change_comment" IS 'comment 1'
          `),
        );
      });

      it('should change column comment from null', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeComment: t.change(t.comment(null), t.comment('comment 2')),
            })),
          () =>
            expectSql(`
              COMMENT ON COLUMN "table"."change_comment" IS 'comment 2'
            `),
          () =>
            expectSql(`
              COMMENT ON COLUMN "table"."change_comment" IS NULL
            `),
        );
      });
    });

    it('should change column compression', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            changeCompression: t.change(
              t.text(),
              t.text().compression('value'),
            ),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_compression" SET COMPRESSION value
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "change_compression" SET COMPRESSION DEFAULT
          `),
      );
    });

    it('should change column compression with custom name', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            naMe: t
              .name('name')
              .change(t.text(), t.text().compression('value')),
          })),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "name" SET COMPRESSION value
          `),
        () =>
          expectSql(`
            ALTER TABLE "table"
              ALTER COLUMN "name" SET COMPRESSION DEFAULT
          `),
      );
    });

    it('should rename column and change it`s type', async () => {
      await testUpAndDown(
        () =>
          db.changeTable('table', (t) => ({
            frOm: t.change(t.string(), t.name('tO').text()),
          })),
        () =>
          expectSql([
            `
              ALTER TABLE "table"
              RENAME COLUMN "fr_om" TO "tO"
            `,
            `
              ALTER TABLE "table"
              ALTER COLUMN "tO" TYPE text
            `,
          ]),
        () =>
          expectSql([
            `
              ALTER TABLE "table"
              RENAME COLUMN "tO" TO "fr_om"
            `,
            `
              ALTER TABLE "table"
              ALTER COLUMN "fr_om" TYPE varchar(255)
            `,
          ]),
      );
    });

    describe('composite primary key', () => {
      it('should add composite primary key via change', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              iD: t.change(t.integer(), t.integer().primaryKey()),
              teXt: t.change(t.integer(), t.integer().primaryKey()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ADD PRIMARY KEY ("i_d", "te_xt")
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "table_pkey"
            `),
        );
      });

      it('should drop composite primary key via change', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              iD: t.change(t.integer().primaryKey(), t.integer()),
              teXt: t.change(t.integer().primaryKey(), t.integer()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "table_pkey"
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              ADD PRIMARY KEY ("i_d", "te_xt")
            `),
        );
      });

      it('should change composite primary key', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              iD: t.change(t.integer().primaryKey(), t.integer()),
              teXt: t.change(
                t.integer().primaryKey(),
                t.integer().primaryKey(),
              ),
              actIve: t.change(t.integer(), t.integer().primaryKey()),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "table_pkey",
              ADD PRIMARY KEY ("te_xt", "act_ive")
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
              DROP CONSTRAINT "table_pkey",
              ADD PRIMARY KEY ("i_d", "te_xt")
            `),
        );
      });
    });

    describe('foreign key', () => {
      it('should add foreign key', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              addFkey: t.change(
                t.integer(),
                t.integer().foreignKey('otherTable', 'foreignId'),
              ),
              addFkeyWithOptions: t.change(
                t.integer(),
                t.integer().foreignKey('otherTable', 'foreignId', {
                  name: 'foreignKeyName',
                  match: 'FULL',
                  onUpdate: 'SET NULL',
                  onDelete: 'CASCADE',
                }),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD CONSTRAINT "table_add_fkey_fkey" FOREIGN KEY ("add_fkey") REFERENCES "otherTable"("foreign_id"),
                ADD CONSTRAINT "foreignKeyName" FOREIGN KEY ("add_fkey_with_options") REFERENCES "otherTable"("foreign_id") MATCH FULL ON DELETE CASCADE ON UPDATE SET NULL
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "table_add_fkey_fkey",
                DROP CONSTRAINT "foreignKeyName"
            `),
        );
      });

      it('should remove foreign key', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              removeFkey: t.change(
                t.integer().foreignKey('otherTable', 'foreignId'),
                t.integer(),
              ),
              removeFkeyWithOptions: t.change(
                t.integer().foreignKey('otherTable', 'foreignId', {
                  name: 'foreignKeyName',
                  match: 'FULL',
                  onUpdate: 'SET NULL',
                  onDelete: 'CASCADE',
                }),
                t.integer(),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "table_remove_fkey_fkey",
                DROP CONSTRAINT "foreignKeyName"
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                ADD CONSTRAINT "table_remove_fkey_fkey" FOREIGN KEY ("remove_fkey") REFERENCES "otherTable"("foreign_id"),
                ADD CONSTRAINT "foreignKeyName" FOREIGN KEY ("remove_fkey_with_options") REFERENCES "otherTable"("foreign_id") MATCH FULL ON DELETE CASCADE ON UPDATE SET NULL
            `),
        );
      });

      it('should change foreign key', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeForeignKey: t.change(
                t.integer().foreignKey('a', 'aId', {
                  name: 'fromFkeyName',
                  match: 'PARTIAL',
                  onUpdate: 'RESTRICT',
                  onDelete: 'SET DEFAULT',
                }),
                t.integer().foreignKey('b', 'bId', {
                  name: 'toFkeyName',
                  match: 'FULL',
                  onUpdate: 'NO ACTION',
                  onDelete: 'CASCADE',
                }),
              ),
            })),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "fromFkeyName",
                ADD CONSTRAINT "toFkeyName" FOREIGN KEY ("change_foreign_key") REFERENCES "b"("b_id") MATCH FULL ON DELETE CASCADE ON UPDATE NO ACTION
            `),
          () =>
            expectSql(`
              ALTER TABLE "table"
                DROP CONSTRAINT "toFkeyName",
                ADD CONSTRAINT "fromFkeyName" FOREIGN KEY ("change_foreign_key") REFERENCES "a"("a_id") MATCH PARTIAL ON DELETE SET DEFAULT ON UPDATE RESTRICT
            `),
        );
      });
    });

    describe('index', () => {
      it('should add index', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              addIndex: t.change(t.integer(), t.integer().index()),
              addIndexWithOptions: t.change(
                t.integer(),
                t.integer().unique({
                  name: 'indexName',
                  collate: 'schema.collation',
                  opclass: 'opclass',
                  order: 'order',
                  nullsNotDistinct: true,
                  using: 'using',
                  include: ['aA', 'bB'],
                  with: 'with',
                  tablespace: 'tablespace',
                  where: 'where',
                  dropMode: 'CASCADE',
                  expression: 'index expression',
                }),
              ),
            })),
          () =>
            expectSql([
              `CREATE INDEX "table_add_index_idx" ON "table" ("add_index")`,
              toLine(`
                CREATE UNIQUE INDEX "indexName"
                  ON "table"
                  USING using ((index expression) COLLATE "schema"."collation" opclass order)
                  INCLUDE ("a_a", "b_b")
                  NULLS NOT DISTINCT
                  WITH (with)
                  TABLESPACE tablespace
                  WHERE where
              `),
            ]),
          () =>
            expectSql([
              `DROP INDEX "table_add_index_idx"`,
              `DROP INDEX "indexName" CASCADE`,
            ]),
        );
      });

      it('should remove index', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              removeIndex: t.change(t.integer().index(), t.integer()),
              removeIndexWithOptions: t.change(
                t.integer().unique({
                  name: 'indexName',
                  collate: 'schema.collation',
                  opclass: 'opclass',
                  order: 'order',
                  nullsNotDistinct: true,
                  using: 'using',
                  include: ['aA', 'bB'],
                  with: 'with',
                  tablespace: 'tablespace',
                  where: 'where',
                  dropMode: 'CASCADE',
                  expression: 'index expression',
                }),
                t.integer(),
              ),
            })),
          () =>
            expectSql([
              `DROP INDEX "table_remove_index_idx"`,
              `DROP INDEX "indexName" CASCADE`,
            ]),
          () =>
            expectSql([
              `CREATE INDEX "table_remove_index_idx" ON "table" ("remove_index")`,
              toLine(`
                CREATE UNIQUE INDEX "indexName"
                  ON "table"
                  USING using ((index expression) COLLATE "schema"."collation" opclass order)
                  INCLUDE ("a_a", "b_b")
                  NULLS NOT DISTINCT
                  WITH (with)
                  TABLESPACE tablespace
                  WHERE where
              `),
            ]),
        );
      });

      it('should change index', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              changeIndex: t.change(
                // @ts-expect-error name as argument is deprecated
                t.integer().index('from', {
                  collate: 'schema.from',
                  opclass: 'from',
                  order: 'from',
                  nullsNotDistinct: false,
                  using: 'from',
                  include: ['aA', 'bB'],
                  with: 'from',
                  tablespace: 'from',
                  where: 'from',
                  dropMode: 'CASCADE',
                }),
                // @ts-expect-error name as argument is deprecated
                t.integer().unique('to', {
                  collate: 'schema.to',
                  opclass: 'to',
                  order: 'to',
                  nullsNotDistinct: true,
                  using: 'to',
                  include: ['cC', 'dD'],
                  with: 'to',
                  tablespace: 'to',
                  where: 'to',
                  dropMode: 'RESTRICT',
                  expression: 'index expression',
                }),
              ),
              changeIndex2: t.change(
                t.integer().index({
                  name: 'from',
                  collate: 'schema.from',
                  opclass: 'from',
                  order: 'from',
                  nullsNotDistinct: false,
                  using: 'from',
                  include: ['aA', 'bB'],
                  with: 'from',
                  tablespace: 'from',
                  where: 'from',
                  dropMode: 'CASCADE',
                }),
                t.integer().unique({
                  name: 'to',
                  collate: 'schema.to',
                  opclass: 'to',
                  order: 'to',
                  nullsNotDistinct: true,
                  using: 'to',
                  include: ['cC', 'dD'],
                  with: 'to',
                  tablespace: 'to',
                  where: 'to',
                  dropMode: 'RESTRICT',
                  expression: 'index expression',
                }),
              ),
            })),
          () =>
            expectSql([
              `DROP INDEX "from" CASCADE`,
              `DROP INDEX "from" CASCADE`,
              toLine(`
                CREATE UNIQUE INDEX "to"
                  ON "table"
                  USING to ((index expression) COLLATE "schema"."to" to to)
                  INCLUDE ("c_c", "d_d")
                  NULLS NOT DISTINCT
                  WITH (to)
                  TABLESPACE to
                  WHERE to
              `),
              toLine(`
                CREATE UNIQUE INDEX "to"
                  ON "table"
                  USING to ((index expression) COLLATE "schema"."to" to to)
                  INCLUDE ("c_c", "d_d")
                  NULLS NOT DISTINCT
                  WITH (to)
                  TABLESPACE to
                  WHERE to
              `),
            ]),
          () =>
            expectSql([
              `DROP INDEX "to" RESTRICT`,
              `DROP INDEX "to" RESTRICT`,
              toLine(`
                CREATE INDEX "from"
                  ON "table"
                  USING from ("change_index" COLLATE "schema"."from" from from)
                  INCLUDE ("a_a", "b_b")
                  WITH (from)
                  TABLESPACE from
                  WHERE from
              `),
              toLine(`
                CREATE INDEX "from"
                  ON "table"
                  USING from ("change_index2" COLLATE "schema"."from" from from)
                  INCLUDE ("a_a", "b_b")
                  WITH (from)
                  TABLESPACE from
                  WHERE from
              `),
            ]),
        );
      });

      it('should change index together with a column change', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              colUmn: t.change(
                t.varchar(100).index(),
                t.text().index({
                  nullsNotDistinct: true,
                }),
              ),
            })),
          () =>
            expectSql([
              `ALTER TABLE "table"\nALTER COLUMN "col_umn" TYPE text`,
              `DROP INDEX "table_col_umn_idx"`,
              `CREATE INDEX "table_col_umn_idx" ON "table" ("col_umn") NULLS NOT DISTINCT`,
            ]),
          () =>
            expectSql([
              `ALTER TABLE "table"\nALTER COLUMN "col_umn" TYPE varchar(100)`,
              `DROP INDEX "table_col_umn_idx"`,
              `CREATE INDEX "table_col_umn_idx" ON "table" ("col_umn")`,
            ]),
        );
      });
    });

    describe('exclude', () => {
      it('should add exclude', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              addExclude: t.change(
                t.integer(),
                // @ts-expect-error name as argument is deprecated
                t.integer().exclude('&&', 'excludeName', {
                  using: 'GIST',
                  collate: 'col',
                  opclass: 'opc',
                  order: 'ASC',
                  include: 'inc',
                  with: 'wit',
                  tablespace: 'tbs',
                  where: 'whe',
                  dropMode: 'CASCADE',
                }),
              ),
              addExclude2: t.change(
                t.integer(),
                t.integer().exclude('&&', {
                  name: 'excludeName',
                  using: 'GIST',
                  collate: 'col',
                  opclass: 'opc',
                  order: 'ASC',
                  include: 'inc',
                  with: 'wit',
                  tablespace: 'tbs',
                  where: 'whe',
                  dropMode: 'CASCADE',
                }),
              ),
            })),
          () =>
            expectSql([
              toLine(`
                ALTER TABLE "table"
                ADD CONSTRAINT "excludeName"
                EXCLUDE USING GIST ("add_exclude" COLLATE "col" opc ASC WITH &&)
                INCLUDE ("inc")
                WITH (wit)
                USING INDEX TABLESPACE tbs
                WHERE whe
              `),
              toLine(`
                ALTER TABLE "table"
                ADD CONSTRAINT "excludeName"
                EXCLUDE USING GIST ("add_exclude2" COLLATE "col" opc ASC WITH &&)
                INCLUDE ("inc")
                WITH (wit)
                USING INDEX TABLESPACE tbs
                WHERE whe
              `),
            ]),
          () =>
            expectSql([
              toLine(`
                ALTER TABLE "table" DROP CONSTRAINT "excludeName" CASCADE
              `),
              toLine(`
                ALTER TABLE "table" DROP CONSTRAINT "excludeName" CASCADE
              `),
            ]),
        );
      });
    });

    describe('rename column', () => {
      it('should rename columns', async () => {
        await testUpAndDown(
          () =>
            db.changeTable('table', (t) => ({
              aA: t.rename('bB'),
              cC: t.rename('dD'),
            })),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                RENAME COLUMN "a_a" TO "b_b"
              `,
              `
                ALTER TABLE "table"
                RENAME COLUMN "c_c" TO "d_d"
              `,
            ]),
          () =>
            expectSql([
              `
                ALTER TABLE "table"
                RENAME COLUMN "b_b" TO "a_a"
              `,
              `
                ALTER TABLE "table"
                RENAME COLUMN "d_d" TO "c_c"
              `,
            ]),
        );
      });
    });
  });
});
