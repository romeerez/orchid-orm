import { expectSql, getDb, resetDb, toLine } from '../rake-db.test-utils';
import { makeColumnTypes, Db, defaultSchemaConfig } from 'pqb';
import { asMock, sql } from 'test-utils';
import { setDefaultLanguage } from 'orchid-core';

const db = getDb();

const testUpAndDown = async (
  fn: (action: 'createTable' | 'dropTable') => Promise<unknown> | void,
  expectUp?: () => void,
  expectDown: () => void = () => expectSql(`DROP TABLE "table"`),
) => {
  resetDb(true);
  await fn('createTable');
  expectUp?.();

  resetDb(false);
  await fn('createTable');
  expectUp && expectDown();

  resetDb(true);
  await fn('dropTable');
  expectUp && expectDown();

  resetDb(false);
  await fn('dropTable');
  expectUp?.();
};

describe('create and drop table', () => {
  it('should interpolate SQL parameters because pg does not support binding params for modifying schema', async () => {
    await db.createTable('table', { noPrimaryKey: true }, (t) => ({
      coL: t.integer().default(sql`1 + ${2}`),
    }));

    expectSql(`
      CREATE TABLE "table" (
        "co_l" int4 NOT NULL DEFAULT 1 + 2
      )
    `);
  });

  it('create and drop an empty table', async () => {
    await testUpAndDown(
      (action) => db[action]('name'),
      () =>
        expectSql(`
          CREATE TABLE "name" (
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should handle table with schema', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('schema.name', (t) => ({
          iD: t.identity().primaryKey(),
        })),
      () =>
        expectSql(`
          CREATE TABLE "schema"."name" (
            "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "schema"."name"
        `),
    );
  });

  it('should handle table with comment', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', { comment: 'this is a table comment' }, (t) => ({
          iD: t.identity().primaryKey(),
        })),
      () =>
        expectSql([
          `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
              )
            `,
          `COMMENT ON TABLE "table" IS 'this is a table comment'`,
        ]),
    );
  });

  it('should add DEFAULT gen_random_uuid() for uuid primary key', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('schema.name', (t) => ({ iD: t.uuid().primaryKey() })),
      () =>
        expectSql(`
          CREATE TABLE "schema"."name" (
            "i_d" uuid PRIMARY KEY DEFAULT gen_random_uuid()
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "schema"."name"
        `),
    );
  });

  it('should not add DEFAULT to uuid primary key if user specifies default(null)', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('name', (t) => ({
          iD: t.uuid().primaryKey().default(null),
        })),
      () =>
        expectSql(`
          CREATE TABLE "name" (
            "i_d" uuid PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should not add DEFAULT if the provided default is a function', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('name', (t) => ({
          iD: t.uuid().primaryKey().default(null),
        })),
      () =>
        expectSql(`
          CREATE TABLE "name" (
            "i_d" uuid PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should create a primary key with a custom name', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('name', (t) => ({
          iD: t.identity().primaryKey('custom'),
        })),
      () =>
        expectSql(`
          CREATE TABLE "name" (
            "i_d" int4 GENERATED BY DEFAULT AS IDENTITY CONSTRAINT "custom" PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should handle `createIfNotExists`, `dropIfExists`, `dropMode`', async () => {
    await testUpAndDown(
      (action) =>
        db[action](
          'table',
          { createIfNotExists: true, dropIfExists: true, dropMode: 'CASCADE' },
          (t) => ({
            iD: t.identity().primaryKey(),
          }),
        ),
      () =>
        expectSql(`
          CREATE TABLE IF NOT EXISTS "table" (
            "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE IF EXISTS "table" CASCADE
        `),
    );
  });

  it('should return a table db interface', async () => {
    await testUpAndDown(async (action) => {
      const { table } = await db[action]('table', (t) => ({
        iD: t.identity().primaryKey(),
        naMe: t.text(),
      }));

      expect(table).toBeInstanceOf(Db);
    });
  });

  describe('columns', () => {
    it('should handle table columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            strIng: t.string(),
            nullAble: t.text().nullable(),
            nonNullable: t.text(),
            citExt: t.citext(),
            varcharWithLength: t.varchar(20),
            decimalWithPrecisionAndScale: t.decimal(10, 5),
            columnWithCompression: t.text().compression('compression'),
            columnWithCollate: t.text().collate('schema.collation'),
            generAted: t.tsvector().generated`'sql'`,
          })),
        () => {
          expectSql(
            `
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "str_ing" varchar(255) NOT NULL,
              "null_able" text,
              "non_nullable" text NOT NULL,
              "cit_ext" citext NOT NULL,
              "varchar_with_length" varchar(20) NOT NULL,
              "decimal_with_precision_and_scale" numeric(10, 5) NOT NULL,
              "column_with_compression" text COMPRESSION compression NOT NULL,
              "column_with_collate" text COLLATE "schema"."collation" NOT NULL,
              "gener_ated" tsvector GENERATED ALWAYS AS ('sql') STORED NOT NULL
            )
          `,
          );
        },
        () => {
          expectSql(
            `
            DROP TABLE "table"
          `,
          );
        },
      );
    });
  });

  describe('identity', () => {
    it('should add identity column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            )
          `),
      );
    });

    it('should add small identity column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.smallint().identity().primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int2 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            )
          `),
      );
    });

    it('should add always generated identity column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity({ always: true }).primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY
            )
          `),
      );
    });

    it('should add identity column with sequence options', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t
              .identity({
                increment: 5,
                start: 10,
                min: 15,
                max: 20,
                cache: 3,
                cycle: true,
              })
              .primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY (${toLine(`
                INCREMENT BY 5
                MINVALUE 15
                MAXVALUE 20
                START WITH 10
                CACHE 3
                CYCLE
              `)}) PRIMARY KEY
            )
          `),
      );
    });
  });

  it('should handle enum column', async () => {
    const enumRows = [['one'], ['two']];

    await testUpAndDown(
      (action) => {
        asMock(db.adapter.arrays).mockResolvedValueOnce({ rows: enumRows });

        return db[action]('table', (t) => ({
          iD: t.identity().primaryKey(),
          enUm: t.enum('mood'),
        }));
      },
      () => {
        expectSql([
          'SELECT unnest(enum_range(NULL::"mood"))::text',
          `
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "en_um" "mood" NOT NULL
            )
          `,
        ]);
      },
      () => {
        expectSql([
          'SELECT unnest(enum_range(NULL::"mood"))::text',
          `
            DROP TABLE "table"
          `,
        ]);
      },
    );
  });

  it('should handle columns with defaults', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          iD: t.identity().primaryKey(),
          withDefault: t.boolean().default(false),
          withDefaultRaw: t.date().default(t.sql(`now()`)),
          jsonWithDefault: t.json().default([]),
        })),
      () =>
        expectSql(
          `
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "with_default" bool NOT NULL DEFAULT false,
              "with_default_raw" date NOT NULL DEFAULT now(),
              "json_with_default" jsonb NOT NULL DEFAULT '[]'
            )
          `,
        ),
    );
  });

  describe('indexes', () => {
    it('should handle indexes', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            withIndex: t.text().unique('indexName', {
              nullsNotDistinct: true,
              using: 'gin',
              collate: 'schema.collation',
              opclass: 'opclass',
              order: 'ASC',
              include: 'iD',
              with: 'fillfactor = 70',
              tablespace: 'tablespace',
              where: 'column = 123',
            }),
            uniqueColumn: t.text().unique({ nullsNotDistinct: true }),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "with_index" text NOT NULL,
                "unique_column" text NOT NULL
              )
            `,
            toLine(`
              CREATE UNIQUE INDEX "indexName"
                ON "table"
                USING gin
                ("with_index" COLLATE "schema"."collation" opclass ASC)
                INCLUDE ("i_d")
                NULLS NOT DISTINCT
                WITH (fillfactor = 70)
                TABLESPACE tablespace
                WHERE column = 123
            `),
            toLine(`
              CREATE UNIQUE INDEX "table_unique_column_idx"
                ON "table" ("unique_column") NULLS NOT DISTINCT
            `),
          ]),
      );
    });

    it("should produce a compact index name when it's too long", async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'reallyLongTableNameConsistingOfSeveralWords',
            { noPrimaryKey: true },
            (t) => ({
              longNameForTheFirstColumn: t.integer(),
              longNameForTheSecondColumn: t.integer(),
            }),
            (t) =>
              t.unique([
                'longNameForTheFirstColumn',
                'longNameForTheSecondColumn',
              ]),
          ),
        () =>
          expectSql([
            `
              CREATE TABLE "reallyLongTableNameConsistingOfSeveralWords" (
                "long_name_for_the_first_column" int4 NOT NULL,
                "long_name_for_the_second_column" int4 NOT NULL
              )
            `,
            `
              CREATE UNIQUE INDEX "reLoTaNaCoOfSeWo_loNaFoThFiCo_loNaFoThSeCo_idx" ON "reallyLongTableNameConsistingOfSeveralWords" ("long_name_for_the_first_column", "long_name_for_the_second_column")
            `,
          ]),
        () =>
          expectSql(`DROP TABLE "reallyLongTableNameConsistingOfSeveralWords"`),
      );
    });
  });

  describe('exclude', () => {
    it('should handle exclude', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', { noPrimaryKey: true }, (t) => ({
            ranGe: t.type('tstzrange').exclude('&&', {
              using: 'GIST',
              collate: 'col',
              opclass: 'opc',
              order: 'DESC NULLS LAST',
              include: 'inc',
              with: 'wit',
              tablespace: 'tbs',
              where: 'whe',
            }),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "ran_ge" tstzrange NOT NULL
              )
            `,
            toLine(`
              ALTER TABLE "table"
                ADD CONSTRAINT "table_ran_ge_exclude"
                EXCLUDE USING GIST ("ran_ge" COLLATE "col" opc DESC NULLS LAST WITH &&)
                INCLUDE ("inc")
                WITH (wit)
                USING INDEX TABLESPACE tbs
                WHERE whe
            `),
          ]),
        () => expectSql(`DROP TABLE "table"`),
      );
    });
  });

  describe('timestamps', () => {
    it('should handle timestamps', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            ...t.timestamps(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "created_at" timestamp with time zone NOT NULL DEFAULT now(),
              "updated_at" timestamp with time zone NOT NULL DEFAULT now()
            )
          `),
      );
    });

    it('should handle timestamps in camel case mode', async () => {
      await testUpAndDown(
        async (action) => {
          db.options.snakeCase = false;

          await db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            ...t.timestamps(),
          }));

          db.options.snakeCase = true;
        },
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "iD" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "createdAt" timestamp with time zone NOT NULL DEFAULT now(),
            "updatedAt" timestamp with time zone NOT NULL DEFAULT now()
          )
        `),
      );
    });

    it('should allow to override timestamp default with `nowSQL` option', async () => {
      await testUpAndDown(
        async (action) => {
          db.options.baseTable = {
            nowSQL: `now() AT TIME ZONE 'UTC'`,
          } as unknown as typeof db.options.baseTable;

          await db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            ...t.timestamps(),
          }));

          db.options.baseTable = undefined;
        },
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'UTC'),
            "updated_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'UTC')
          )
        `),
      );
    });
  });

  it('should handle column with explicit name', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          columnKey: t.name('its_a_columnName').identity().primaryKey(),
        })),
      () =>
        expectSql(`
          CREATE TABLE "table" (
            "its_a_columnName" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
          )
        `),
    );
  });

  describe('column comment', () => {
    it('should handle column comment', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey().comment('this is a column comment'),
          })),
        () =>
          expectSql([
            `
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            )
          `,
            `COMMENT ON COLUMN "table"."i_d" IS 'this is a column comment'`,
          ]),
      );
    });
  });

  describe('composite primary key', () => {
    it('should support composite primary key defined on multiple columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.integer().primaryKey(),
            naMe: t.text().primaryKey(),
            actIve: t.boolean().primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 NOT NULL,
              "na_me" text NOT NULL,
              "act_ive" bool NOT NULL,
              PRIMARY KEY ("i_d", "na_me", "act_ive")
            )
          `),
      );
    });

    it('should support composite primary key defined on table', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.integer(),
              naMe: t.text(),
              actIve: t.boolean(),
            }),
            (t) => t.primaryKey(['iD', 'naMe', 'actIve']),
          ),
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "i_d" int4 NOT NULL,
            "na_me" text NOT NULL,
            "act_ive" bool NOT NULL,
            PRIMARY KEY ("i_d", "na_me", "act_ive")
          )
        `),
      );
    });

    it('should support composite primary key with constraint name', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.integer(),
              naMe: t.text(),
              actIve: t.boolean(),
            }),
            (t) => t.primaryKey(['iD', 'naMe', 'actIve'], 'primaryKeyName'),
          ),
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "i_d" int4 NOT NULL,
            "na_me" text NOT NULL,
            "act_ive" bool NOT NULL,
            CONSTRAINT "primaryKeyName" PRIMARY KEY ("i_d", "na_me", "act_ive")
          )
        `),
      );
    });

    it('should support composite primary key defined on table and multiple columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.integer().primaryKey(),
              naMe: t.text().primaryKey(),
              actIve: t.boolean().primaryKey(),
              anoTher: t.date(),
              oNe: t.decimal(),
            }),
            (t) => t.primaryKey(['anoTher', 'oNe']),
          ),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 NOT NULL,
              "na_me" text NOT NULL,
              "act_ive" bool NOT NULL,
              "ano_ther" date NOT NULL,
              "o_ne" numeric NOT NULL,
              PRIMARY KEY ("i_d", "na_me", "act_ive", "ano_ther", "o_ne")
            )
          `),
      );
    });

    it('should should strip duplicated primary key columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              aA: t.integer().primaryKey(),
              bB: t.text().primaryKey(),
            }),
            (t) => t.primaryKey(['aA', 'bB']),
          ),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "a_a" int4 NOT NULL,
              "b_b" text NOT NULL,
              PRIMARY KEY ("a_a", "b_b")
            )
          `),
      );
    });
  });

  describe('composite index', () => {
    it('should support composite index', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.identity().primaryKey(),
              naMe: t.text(),
            }),
            (t) =>
              t.index(
                ['iD', { column: 'naMe', order: 'DESC' }],
                'compositeIndexOnTable',
                {
                  nullsNotDistinct: true,
                },
              ),
          ),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "na_me" text NOT NULL
              )
            `,
            `
              CREATE INDEX "compositeIndexOnTable" ON "table" ("i_d", "na_me" DESC) NULLS NOT DISTINCT
            `,
          ]),
      );
    });

    it('should support composite unique index', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.identity().primaryKey(),
              naMe: t.text(),
            }),
            (t) =>
              t.unique(
                ['iD', { column: 'naMe', order: 'DESC' }],
                'compositeIndexOnTable',
                {
                  nullsNotDistinct: true,
                },
              ),
          ),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "na_me" text NOT NULL
              )
            `,
            `
              CREATE UNIQUE INDEX "compositeIndexOnTable" ON "table" ("i_d", "na_me" DESC) NULLS NOT DISTINCT
            `,
          ]),
      );
    });
  });

  describe('search index', () => {
    beforeEach(() => {
      delete db.options.language;
      setDefaultLanguage('english');
    });

    const t = makeColumnTypes(defaultSchemaConfig);
    const columns = {
      iD: t.identity().primaryKey(),
      titLe: t.text(),
      teXt: t.text(),
    };

    const tableSQL = `
      CREATE TABLE "table" (
        "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "tit_le" text NOT NULL,
        "te_xt" text NOT NULL
      )
    `;

    it('should add a search index for a single column', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            () => columns,
            (t) => t.searchIndex(['teXt']),
          ),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_te_xt_idx" ON "table" USING gin (to_tsvector('english', "te_xt"))
            `,
          ]),
      );
    });

    it('should support an index for search with english by default', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            () => columns,
            (t) => t.searchIndex(['titLe', 'teXt']),
          ),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('english', "tit_le" || ' ' || "te_xt"))
            `,
          ]),
      );
    });

    it('should support an index for search with a custom default language', async () => {
      db.options.language = 'Ukrainian';

      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            () => columns,
            (t) => t.searchIndex(['titLe', 'teXt']),
          ),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('Ukrainian', "tit_le" || ' ' || "te_xt"))
            `,
          ]),
      );
    });

    it('should support an index for search with a custom default language set in the table options', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            { language: 'Ukrainian' },
            () => columns,
            (t) => t.searchIndex(['titLe', 'teXt']),
          ),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('Ukrainian', "tit_le" || ' ' || "te_xt"))
            `,
          ]),
      );
    });

    it('should support an index for search with a custom default language set in the index options', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            () => columns,
            (t) =>
              t.searchIndex(['titLe', 'teXt'], {
                language: 'Ukrainian',
              }),
          ),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector('Ukrainian', "tit_le" || ' ' || "te_xt"))
            `,
          ]),
      );
    });

    it('should use a language from a column', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            () => columns,
            (t) =>
              t.searchIndex(['titLe', 'teXt'], {
                languageColumn: 'lang',
              }),
          ),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin (to_tsvector("lang", "tit_le" || ' ' || "te_xt"))
            `,
          ]),
      );
    });

    it('should set weights on columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            () => columns,
            (t) =>
              t.searchIndex([
                { column: 'titLe', weight: 'A' },
                { column: 'teXt', weight: 'B' },
              ]),
          ),
        () =>
          expectSql([
            tableSQL,
            toLine(`
              CREATE INDEX "table_tit_le_te_xt_idx" ON "table" USING gin
                ((setweight(to_tsvector('english', coalesce("tit_le", '')), 'A') ||
                 setweight(to_tsvector('english', coalesce("te_xt", '')), 'B')))
            `),
          ]),
      );
    });

    it('should index a generated column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t.tsvector().generated(['titLe', 'teXt']).searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "tit_le" text NOT NULL,
                "te_xt" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS (to_tsvector('english', coalesce("tit_le", '') || ' ' || coalesce("te_xt", ''))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });

    it('should index a generated column with weights', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t
              .tsvector()
              .generated({ titLe: 'A', teXt: 'B' })
              .searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "tit_le" text NOT NULL,
                "te_xt" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS ((setweight(to_tsvector('english', coalesce("tit_le", '')), 'A') || setweight(to_tsvector('english', coalesce("te_xt", '')), 'B'))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });

    it('should index a generated column with a configured default language', async () => {
      db.options.language = 'Ukrainian';

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t.tsvector().generated(['titLe', 'teXt']).searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "tit_le" text NOT NULL,
                "te_xt" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS (to_tsvector('Ukrainian', coalesce("tit_le", '') || ' ' || coalesce("te_xt", ''))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });

    it('should index a generated column with a custom default language', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t
              .tsvector()
              .generated('Ukrainian', ['titLe', 'teXt'])
              .searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "tit_le" text NOT NULL,
                "te_xt" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS (to_tsvector('Ukrainian', coalesce("tit_le", '') || ' ' || coalesce("te_xt", ''))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });
  });

  describe('composite exclude', () => {
    it('should support composite exclude', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.identity().primaryKey(),
              start: t.timestamp(),
              end: t.timestamp(),
            }),
            (t) =>
              t.exclude(
                [
                  {
                    column: 'iD',
                    with: '=',
                    collate: 'col',
                    opclass: 'opc',
                    order: 'DESC NULLS LAST',
                  },
                  { expression: `tstzrange("start", "end")`, with: '&&' },
                ],
                {
                  using: 'GIST',
                  include: ['a', 'b'],
                  with: 'wit',
                  tablespace: 'tbs',
                  where: 'whe',
                  dropMode: 'CASCADE',
                },
              ),
          ),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "start" timestamp with time zone NOT NULL,
                "end" timestamp with time zone NOT NULL
              )
            `,
            toLine(`
              ALTER TABLE "table"
              ADD CONSTRAINT "table_i_d_expression_exclude"
              EXCLUDE USING GIST ("i_d" COLLATE "col" opc DESC NULLS LAST WITH =,
                (tstzrange("start", "end")) WITH &&)
              INCLUDE ("a", "b")
              WITH (wit)
              USING INDEX TABLESPACE tbs
              WHERE whe
            `),
          ]),
      );
    });
  });

  describe('foreign key', () => {
    it('should handle columns with foreign key', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            columnWithForeignKey: t.integer().foreignKey('table', 'colUmn', {
              name: 'fkeyConstraint',
              match: 'FULL',
              onUpdate: 'CASCADE',
              onDelete: 'CASCADE',
            }),
          })),
        () =>
          expectSql(
            `
              CREATE TABLE "table" (
                "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "column_with_foreign_key" int4 NOT NULL CONSTRAINT "fkeyConstraint" REFERENCES "table"("col_umn") MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE
              )
            `,
          ),
      );
    });

    it('should support composite foreign key', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.identity().primaryKey(),
              naMe: t.text(),
            }),
            (t) =>
              t.foreignKey(
                ['iD', 'naMe'],
                'otherTable',
                ['foreignId', 'foreignName'],
                {
                  name: 'constraintName',
                  match: 'FULL',
                  onUpdate: 'CASCADE',
                  onDelete: 'CASCADE',
                },
              ),
          ),
        () => {
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "na_me" text NOT NULL,
              ${toLine(`
                CONSTRAINT "constraintName"
                  FOREIGN KEY ("i_d", "na_me")
                  REFERENCES "otherTable"("foreign_id", "foreign_name")
                  MATCH FULL
                  ON DELETE CASCADE
                  ON UPDATE CASCADE
              `)}
            )
          `);
        },
      );
    });

    it('should compact long foreign key names', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'reallyLongTableNameConsistingOfSeveralWords',
            { noPrimaryKey: true },
            (t) => ({
              longNameForTheFirstColumn: t.integer(),
              longNameForTheSecondColumn: t.integer(),
            }),
            (t) =>
              t.foreignKey(
                ['longNameForTheFirstColumn', 'longNameForTheSecondColumn'],
                'otherTable',
                ['foreignOne', 'foreignTwo'],
              ),
          ),
        () =>
          expectSql(`
            CREATE TABLE "reallyLongTableNameConsistingOfSeveralWords" (
              "long_name_for_the_first_column" int4 NOT NULL,
              "long_name_for_the_second_column" int4 NOT NULL,
              ${toLine(`
                CONSTRAINT "reLoTaNaCoOfSeWo_loNaFoThFiCo_loNaFoThSeCo_fkey"
                  FOREIGN KEY ("long_name_for_the_first_column", "long_name_for_the_second_column")
                  REFERENCES "otherTable"("foreign_one", "foreign_two")
              `)}
            )
          `),
        () =>
          expectSql('DROP TABLE "reallyLongTableNameConsistingOfSeveralWords"'),
      );
    });
  });

  describe('check', () => {
    it('should support database column checks', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            columnWithCheck: t
              .text()
              .check(t.sql('length("column_with_check") > 10'))
              .check(t.sql('length("column_with_check") > 20')),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "column_with_check" text NOT NULL CHECK (length("column_with_check") > 10), CHECK (length("column_with_check") > 20)
            )
          `),
      );
    });

    it('should support named database column checks', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            iD: t.identity().primaryKey(),
            columnWithCheck: t
              .text()
              .check(t.sql('length("column_with_check") > 10'), 'gt10')
              .check(t.sql('length("column_with_check") < 20'), 'lt20'),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "column_with_check" text NOT NULL CONSTRAINT "gt10" CHECK (length("column_with_check") > 10), CONSTRAINT "lt20" CHECK (length("column_with_check") < 20)
            )
          `),
      );
    });

    it('should support database check on the table', async () => {
      await testUpAndDown(
        (action) =>
          db[action](
            'table',
            (t) => ({
              iD: t.identity().primaryKey(),
            }),
            (t) => [t.check(t.sql('sql')), t.check(t.sql('sql'), 'name')],
          ),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              CONSTRAINT "table_check" CHECK (sql),
              CONSTRAINT "name" CHECK (sql)
            )
          `),
      );
    });
  });

  it('should support column of custom type', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          iD: t.identity().primaryKey(),
          colUmn: t.type('customType'),
        })),
      () =>
        expectSql(`
          CREATE TABLE "table" (
            "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "col_umn" customType NOT NULL
          )
        `),
    );
  });

  it('should support domain column', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          iD: t.identity().primaryKey(),
          domainColumn: t.domain('domainName'),
        })),
      () =>
        expectSql(`
          CREATE TABLE "table" (
            "i_d" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "domain_column" "domainName" NOT NULL
          )
        `),
    );
  });

  describe('noPrimaryKey', () => {
    const { warn } = console;
    afterAll(() => {
      db.options.noPrimaryKey = undefined;
      console.warn = warn;
    });

    it('should throw by default when no primary key', async () => {
      await testUpAndDown((action) =>
        expect(() => db[action]('table', () => ({}))).rejects.toThrow(
          'Table table has no primary key.\nYou can suppress this error by setting { noPrimaryKey: true } after a table name.',
        ),
      );
    });

    it('should throw when no primary key and noPrimaryKey is set to `error`', async () => {
      await testUpAndDown((action) => {
        db.options.noPrimaryKey = 'error';

        return expect(() => db[action]('table', () => ({}))).rejects.toThrow(
          'Table table has no primary key.\nYou can suppress this error by setting { noPrimaryKey: true } after a table name.',
        );
      });
    });

    it('should warn when no primary key and noPrimaryKey is set to `warning`', async () => {
      await testUpAndDown((action) => {
        console.warn = jest.fn();
        db.options.noPrimaryKey = 'warning';

        db[action]('table', () => ({}));

        expect(console.warn).toBeCalledWith(
          'Table table has no primary key.\nYou can suppress this error by setting { noPrimaryKey: true } after a table name.',
        );
      });
    });

    it('should not throw when no primary key and noPrimaryKey is set to `ignore`', async () => {
      await testUpAndDown((action) => {
        db.options.noPrimaryKey = 'ignore';

        expect(() => db[action]('table', () => ({}))).not.toThrow();
      });
    });

    it(`should not throw if option is set to \`true\` as a option`, async () => {
      await testUpAndDown((action) => {
        db.options.noPrimaryKey = 'error';

        expect(() =>
          db[action]('table', { noPrimaryKey: true }, () => ({})),
        ).not.toThrow();
      });
    });
  });
});
