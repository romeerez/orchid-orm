import { expectSql, getDb, resetDb, toLine } from '../rake-db.test-utils';
import { makeColumnTypes, Db, defaultSchemaConfig } from 'pqb';
import { asMock } from 'test-utils';
import { setDefaultLanguage } from 'orchid-core';

const db = getDb();

const testUpAndDown = async (
  fn: (action: 'createTable' | 'dropTable') => Promise<unknown> | void,
  expectUp?: () => void,
  expectDown: () => void = () => expectSql(`DROP TABLE "table"`),
) => {
  resetDb(true);
  await fn('createTable');
  expectUp?.();

  resetDb(false);
  await fn('createTable');
  expectUp && expectDown();

  resetDb(true);
  await fn('dropTable');
  expectUp && expectDown();

  resetDb(false);
  await fn('dropTable');
  expectUp?.();
};

describe('create and drop table', () => {
  beforeEach(() => {
    db.options.snakeCase = false;
  });

  it('create and drop an empty table', async () => {
    await testUpAndDown(
      (action) => db[action]('name'),
      () =>
        expectSql(`
          CREATE TABLE "name" (
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should handle table with schema', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('schema.name', (t) => ({
          id: t.identity().primaryKey(),
        })),
      () =>
        expectSql(`
          CREATE TABLE "schema"."name" (
            "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "schema"."name"
        `),
    );
  });

  it('should handle table with comment', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', { comment: 'this is a table comment' }, (t) => ({
          id: t.identity().primaryKey(),
        })),
      () =>
        expectSql([
          `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
              )
            `,
          `COMMENT ON TABLE "table" IS 'this is a table comment'`,
        ]),
    );
  });

  it('should add DEFAULT gen_random_uuid() for uuid primary key', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('schema.name', (t) => ({ id: t.uuid().primaryKey() })),
      () =>
        expectSql(`
          CREATE TABLE "schema"."name" (
            "id" uuid PRIMARY KEY DEFAULT gen_random_uuid()
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "schema"."name"
        `),
    );
  });

  it('should not add DEFAULT to uuid primary key if user specifies default(null)', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('name', (t) => ({
          id: t.uuid().primaryKey().default(null),
        })),
      () =>
        expectSql(`
          CREATE TABLE "name" (
            "id" uuid PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should not add DEFAULT if the provided default is a function', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('name', (t) => ({
          id: t.uuid().primaryKey().default(null),
        })),
      () =>
        expectSql(`
          CREATE TABLE "name" (
            "id" uuid PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should create a primary key with a custom name', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('name', (t) => ({
          id: t.identity().primaryKey({ name: 'custom' }),
        })),
      () =>
        expectSql(`
          CREATE TABLE "name" (
            "id" int4 GENERATED BY DEFAULT AS IDENTITY CONSTRAINT "custom" PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE "name"
        `),
    );
  });

  it('should handle `createIfNotExists`, `dropIfExists`, `dropMode`', async () => {
    await testUpAndDown(
      (action) =>
        db[action](
          'table',
          { createIfNotExists: true, dropIfExists: true, dropMode: 'CASCADE' },
          (t) => ({
            id: t.identity().primaryKey(),
          }),
        ),
      () =>
        expectSql(`
          CREATE TABLE IF NOT EXISTS "table" (
            "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
          )
        `),
      () =>
        expectSql(`
          DROP TABLE IF EXISTS "table" CASCADE
        `),
    );
  });

  it('should return a table db interface', async () => {
    await testUpAndDown(async (action) => {
      const { table } = await db[action]('table', (t) => ({
        id: t.identity().primaryKey(),
        name: t.text(),
      }));

      expect(table).toBeInstanceOf(Db);
    });
  });

  describe('columns', () => {
    it('should handle table columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            string: t.string(),
            nullable: t.text().nullable(),
            nonNullable: t.text(),
            citext: t.citext(),
            varcharWithLength: t.varchar(20),
            decimalWithPrecisionAndScale: t.decimal(10, 5),
            columnWithCompression: t.text().compression('compression'),
            columnWithCollate: t.text().collate('schema.collation'),
            generated: t.tsvector().generated`'sql'`,
          })),
        () => {
          expectSql(
            `
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "string" varchar(255) NOT NULL,
              "nullable" text,
              "nonNullable" text NOT NULL,
              "citext" citext NOT NULL,
              "varcharWithLength" varchar(20) NOT NULL,
              "decimalWithPrecisionAndScale" numeric(10, 5) NOT NULL,
              "columnWithCompression" text COMPRESSION compression NOT NULL,
              "columnWithCollate" text COLLATE "schema"."collation" NOT NULL,
              "generated" tsvector GENERATED ALWAYS AS ('sql') STORED NOT NULL
            )
          `,
          );
        },
        () => {
          expectSql(
            `
            DROP TABLE "table"
          `,
          );
        },
      );
    });

    it('should handle columns in snakeCase mode', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', { snakeCase: true }, (t) => ({
            id: t.identity().primaryKey(),
            columnName: t.text(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "column_name" text NOT NULL
            )
          `),
      );
    });
  });

  describe('identity', () => {
    it('should add identity column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', { snakeCase: true }, (t) => ({
            id: t.identity().primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            )
          `),
      );
    });

    it('should add small identity column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', { snakeCase: true }, (t) => ({
            id: t.smallint().identity().primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int2 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            )
          `),
      );
    });

    it('should add always generated identity column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', { snakeCase: true }, (t) => ({
            id: t.identity({ always: true }).primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY
            )
          `),
      );
    });

    it('should add identity column with sequence options', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', { snakeCase: true }, (t) => ({
            id: t
              .identity({
                increment: 5,
                start: 10,
                min: 15,
                max: 20,
                cache: 3,
                cycle: true,
              })
              .primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY (${toLine(`
                INCREMENT BY 5
                MINVALUE 15
                MAXVALUE 20
                START WITH 10
                CACHE 3
                CYCLE
              `)}) PRIMARY KEY
            )
          `),
      );
    });
  });

  it('should handle enum column', async () => {
    const enumRows = [['one'], ['two']];

    await testUpAndDown(
      (action) => {
        asMock(db.adapter.arrays).mockResolvedValueOnce({ rows: enumRows });

        return db[action]('table', (t) => ({
          id: t.identity().primaryKey(),
          enum: t.enum('mood'),
        }));
      },
      () => {
        expectSql([
          'SELECT unnest(enum_range(NULL::"mood"))::text',
          `
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "enum" "mood" NOT NULL
            )
          `,
        ]);
      },
      () => {
        expectSql([
          'SELECT unnest(enum_range(NULL::"mood"))::text',
          `
            DROP TABLE "table"
          `,
        ]);
      },
    );
  });

  it('should handle columns with defaults', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          id: t.identity().primaryKey(),
          withDefault: t.boolean().default(false),
          withDefaultRaw: t.date().default(t.sql(`now()`)),
          jsonWithDefault: t.json().default([]),
        })),
      () =>
        expectSql(
          `
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "withDefault" bool NOT NULL DEFAULT false,
              "withDefaultRaw" date NOT NULL DEFAULT now(),
              "jsonWithDefault" jsonb NOT NULL DEFAULT '[]'
            )
          `,
        ),
    );
  });

  describe('indexes', () => {
    it('should handle indexes', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            withIndex: t.text().index({
              name: 'indexName',
              unique: true,
              nullsNotDistinct: true,
              using: 'gin',
              collate: 'schema.collation',
              opclass: 'opclass',
              order: 'ASC',
              include: 'id',
              with: 'fillfactor = 70',
              tablespace: 'tablespace',
              where: 'column = 123',
            }),
            uniqueColumn: t.text().unique({ nullsNotDistinct: true }),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "withIndex" text NOT NULL,
                "uniqueColumn" text NOT NULL
              )
            `,
            toLine(`
              CREATE UNIQUE INDEX "indexName"
                ON "table"
                USING gin
                ("withIndex" COLLATE "schema"."collation" opclass ASC)
                INCLUDE ("id")
                NULLS NOT DISTINCT
                WITH (fillfactor = 70)
                TABLESPACE tablespace
                WHERE column = 123
            `),
            toLine(`
              CREATE UNIQUE INDEX "table_uniqueColumn_idx"
                ON "table" ("uniqueColumn") NULLS NOT DISTINCT
            `),
          ]),
      );
    });

    it('should handle indexes in snakeCase mode', async () => {
      db.options.snakeCase = true;

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            withIndex: t.text().index(),
            uniqueColumn: t.text().unique(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "with_index" text NOT NULL,
                "unique_column" text NOT NULL
              )
            `,
            toLine(`
              CREATE INDEX "table_with_index_idx" ON "table" ("with_index")
            `),
            toLine(`
              CREATE UNIQUE INDEX "table_unique_column_idx" ON "table" ("unique_column")
            `),
          ]),
      );
    });
  });

  describe('timestamps', () => {
    it('should handle timestamps', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            ...t.timestamps(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "createdAt" timestamp with time zone NOT NULL DEFAULT now(),
              "updatedAt" timestamp with time zone NOT NULL DEFAULT now()
            )
          `),
      );
    });

    it('should handle timestamps in snake case mode', async () => {
      await testUpAndDown(
        async (action) => {
          db.options.snakeCase = true;

          await db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            ...t.timestamps(),
          }));

          db.options.snakeCase = false;
        },
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "created_at" timestamp with time zone NOT NULL DEFAULT now(),
            "updated_at" timestamp with time zone NOT NULL DEFAULT now()
          )
        `),
      );
    });

    it('should allow to override timestamp default with `nowSQL` option', async () => {
      await testUpAndDown(
        async (action) => {
          db.options.baseTable = {
            nowSQL: `now() AT TIME ZONE 'UTC'`,
          } as unknown as typeof db.options.baseTable;

          await db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            ...t.timestamps(),
          }));

          db.options.baseTable = undefined;
        },
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "createdAt" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'UTC'),
            "updatedAt" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'UTC')
          )
        `),
      );
    });
  });

  it('should handle column with explicit name', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          columnKey: t.name('its_a_columnName').identity().primaryKey(),
        })),
      () =>
        expectSql(`
          CREATE TABLE "table" (
            "its_a_columnName" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
          )
        `),
    );
  });

  describe('column comment', () => {
    it('should handle column comment', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey().comment('this is a column comment'),
          })),
        () =>
          expectSql([
            `
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            )
          `,
            `COMMENT ON COLUMN "table"."id" IS 'this is a column comment'`,
          ]),
      );
    });

    it('should handle column comment in snakeCase mode', async () => {
      db.options.snakeCase = true;

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            columnName: t
              .identity()
              .primaryKey()
              .comment('this is a column comment'),
          })),
        () =>
          expectSql([
            `
            CREATE TABLE "table" (
              "column_name" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
            )
          `,
            `COMMENT ON COLUMN "table"."column_name" IS 'this is a column comment'`,
          ]),
      );
    });
  });

  describe('composite primary key', () => {
    it('should support composite primary key defined on multiple columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.integer().primaryKey(),
            name: t.text().primaryKey(),
            active: t.boolean().primaryKey(),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 NOT NULL,
              "name" text NOT NULL,
              "active" bool NOT NULL,
              PRIMARY KEY ("id", "name", "active")
            )
          `),
      );
    });

    it('should support composite primary key defined on table', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.integer(),
            name: t.text(),
            active: t.boolean(),
            ...t.primaryKey(['id', 'name', 'active']),
          })),
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "id" int4 NOT NULL,
            "name" text NOT NULL,
            "active" bool NOT NULL,
            PRIMARY KEY ("id", "name", "active")
          )
        `),
      );
    });

    it('should support composite primary key with constraint name', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.integer(),
            name: t.text(),
            active: t.boolean(),
            ...t.primaryKey(['id', 'name', 'active'], {
              name: 'primaryKeyName',
            }),
          })),
        () =>
          expectSql(`
          CREATE TABLE "table" (
            "id" int4 NOT NULL,
            "name" text NOT NULL,
            "active" bool NOT NULL,
            CONSTRAINT "primaryKeyName" PRIMARY KEY ("id", "name", "active")
          )
        `),
      );
    });

    it('should support composite primary key defined on table and multiple columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.integer().primaryKey(),
            name: t.text().primaryKey(),
            active: t.boolean().primaryKey(),
            another: t.date(),
            one: t.decimal(),
            ...t.primaryKey(['another', 'one']),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 NOT NULL,
              "name" text NOT NULL,
              "active" bool NOT NULL,
              "another" date NOT NULL,
              "one" numeric NOT NULL,
              PRIMARY KEY ("id", "name", "active", "another", "one")
            )
          `),
      );
    });

    it('should support composite primary key defined on multiple columns', async () => {
      db.options.snakeCase = true;

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            idColumn: t.integer().primaryKey(),
            nameColumn: t.text().primaryKey(),
            activeColumn: t.boolean().primaryKey(),
            anotherColumn: t.date(),
            oneColumn: t.decimal(),
            ...t.primaryKey(['anotherColumn', 'oneColumn']),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id_column" int4 NOT NULL,
              "name_column" text NOT NULL,
              "active_column" bool NOT NULL,
              "another_column" date NOT NULL,
              "one_column" numeric NOT NULL,
              PRIMARY KEY ("id_column", "name_column", "active_column", "another_column", "one_column")
            )
          `),
      );
    });
  });

  describe('composite index', () => {
    it('should support composite index', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            name: t.text(),
            ...t.index(['id', { column: 'name', order: 'DESC' }], {
              name: 'compositeIndexOnTable',
              nullsNotDistinct: true,
            }),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" text NOT NULL
              )
            `,
            `
              CREATE INDEX "compositeIndexOnTable" ON "table" ("id", "name" DESC) NULLS NOT DISTINCT
            `,
          ]),
      );
    });

    it('should support composite unique index', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            name: t.text(),
            ...t.unique(['id', { column: 'name', order: 'DESC' }], {
              name: 'compositeIndexOnTable',
              nullsNotDistinct: true,
            }),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" text NOT NULL
              )
            `,
            `
              CREATE UNIQUE INDEX "compositeIndexOnTable" ON "table" ("id", "name" DESC) NULLS NOT DISTINCT
            `,
          ]),
      );
    });

    it('should support composite index and composite unique index in snakeCase mode', async () => {
      db.options.snakeCase = true;

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            idColumn: t.identity().primaryKey(),
            nameColumn: t.text(),
            ...t.index(['idColumn', { column: 'nameColumn', order: 'DESC' }]),
            ...t.unique(['idColumn', { column: 'nameColumn', order: 'DESC' }]),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id_column" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name_column" text NOT NULL
              )
            `,
            `
              CREATE INDEX "table_id_column_name_column_idx" ON "table" ("id_column", "name_column" DESC)
            `,
            `
              CREATE UNIQUE INDEX "table_id_column_name_column_idx" ON "table" ("id_column", "name_column" DESC)
            `,
          ]),
      );
    });
  });

  describe('search index', () => {
    beforeEach(() => {
      delete db.options.language;
      setDefaultLanguage('english');
    });

    const t = makeColumnTypes(defaultSchemaConfig);
    const columns = {
      id: t.identity().primaryKey(),
      title: t.text(0, 100),
      text: t.text(0, 10000),
    };

    const tableSQL = `
      CREATE TABLE "table" (
        "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "title" text NOT NULL,
        "text" text NOT NULL
      )
    `;

    it('should add a search index for a single column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            ...t.searchIndex('text'),
          })),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_text_idx" ON "table" USING gin (to_tsvector('english', "text"))
            `,
          ]),
      );
    });

    it('should support an index for search with english by default', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            ...t.searchIndex(['title', 'text']),
          })),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_title_text_idx" ON "table" USING gin (to_tsvector('english', "title" || ' ' || "text"))
            `,
          ]),
      );
    });

    it('should support an index for search with a custom default language', async () => {
      db.options.language = 'Ukrainian';

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            ...t.searchIndex(['title', 'text']),
          })),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_title_text_idx" ON "table" USING gin (to_tsvector('Ukrainian', "title" || ' ' || "text"))
            `,
          ]),
      );
    });

    it('should support an index for search with a custom default language set in the table options', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', { language: 'Ukrainian' }, (t) => ({
            ...columns,
            ...t.searchIndex(['title', 'text']),
          })),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_title_text_idx" ON "table" USING gin (to_tsvector('Ukrainian', "title" || ' ' || "text"))
            `,
          ]),
      );
    });

    it('should support an index for search with a custom default language set in the index options', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            ...t.searchIndex(['title', 'text'], {
              language: 'Ukrainian',
            }),
          })),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_title_text_idx" ON "table" USING gin (to_tsvector('Ukrainian', "title" || ' ' || "text"))
            `,
          ]),
      );
    });

    it('should use a language from a column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            ...t.searchIndex(['title', 'text'], {
              languageColumn: 'lang',
            }),
          })),
        () =>
          expectSql([
            tableSQL,
            `
              CREATE INDEX "table_title_text_idx" ON "table" USING gin (to_tsvector("lang", "title" || ' ' || "text"))
            `,
          ]),
      );
    });

    it('should set weights on columns', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            ...t.searchIndex([
              { column: 'title', weight: 'A' },
              { column: 'text', weight: 'B' },
            ]),
          })),
        () =>
          expectSql([
            tableSQL,
            toLine(`
              CREATE INDEX "table_title_text_idx" ON "table" USING gin
                ((setweight(to_tsvector('english', coalesce("title", '')), 'A') ||
                 setweight(to_tsvector('english', coalesce("text", '')), 'B')))
            `),
          ]),
      );
    });

    it('should index a generated column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t.tsvector().generated(['title', 'text']).searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "title" text NOT NULL,
                "text" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS (to_tsvector('english', coalesce("title", '') || ' ' || coalesce("text", ''))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });

    it('should index a generated column with weights', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t
              .tsvector()
              .generated({ title: 'A', text: 'B' })
              .searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "title" text NOT NULL,
                "text" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS ((setweight(to_tsvector('english', coalesce("title", '')), 'A') || setweight(to_tsvector('english', coalesce("text", '')), 'B'))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });

    it('should index a generated column with a configured default language', async () => {
      db.options.language = 'Ukrainian';

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t.tsvector().generated(['title', 'text']).searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "title" text NOT NULL,
                "text" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS (to_tsvector('Ukrainian', coalesce("title", '') || ' ' || coalesce("text", ''))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });

    it('should index a generated column with a custom default language', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            ...columns,
            generated: t
              .tsvector()
              .generated('Ukrainian', ['title', 'text'])
              .searchIndex(),
          })),
        () =>
          expectSql([
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "title" text NOT NULL,
                "text" text NOT NULL,
                "generated" tsvector GENERATED ALWAYS AS (to_tsvector('Ukrainian', coalesce("title", '') || ' ' || coalesce("text", ''))) STORED NOT NULL
              )
            `,
            `
              CREATE INDEX "table_generated_idx" ON "table" USING GIN ("generated")
            `,
          ]),
      );
    });
  });

  describe('foreign key', () => {
    it('should handle columns with foreign key', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            columnWithForeignKey: t.integer().foreignKey('table', 'column', {
              name: 'fkeyConstraint',
              match: 'FULL',
              onUpdate: 'CASCADE',
              onDelete: 'CASCADE',
            }),
          })),
        () =>
          expectSql(
            `
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "columnWithForeignKey" int4 NOT NULL CONSTRAINT "fkeyConstraint" REFERENCES "table"("column") MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE
              )
            `,
          ),
      );
    });

    it('should handle column with foreign key in snakeCase mode', async () => {
      db.options.snakeCase = true;

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            columnWithForeignKey: t
              .integer()
              .foreignKey('table', 'otherColumn'),
          })),
        () =>
          expectSql(`
              CREATE TABLE "table" (
                "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "column_with_foreign_key" int4 NOT NULL REFERENCES "table"("other_column")
              )
          `),
      );
    });

    it('should support composite foreign key', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            name: t.text(),
            ...t.foreignKey(
              ['id', 'name'],
              'otherTable',
              ['foreignId', 'foreignName'],
              {
                name: 'constraintName',
                match: 'FULL',
                onUpdate: 'CASCADE',
                onDelete: 'CASCADE',
              },
            ),
          })),
        () => {
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "name" text NOT NULL,
              ${toLine(`
                CONSTRAINT "constraintName"
                  FOREIGN KEY ("id", "name")
                  REFERENCES "otherTable"("foreignId", "foreignName")
                  MATCH FULL
                  ON DELETE CASCADE
                  ON UPDATE CASCADE
              `)}
            )
          `);
        },
      );
    });

    it('should support composite foreign key in snakeCase mode', async () => {
      db.options.snakeCase = true;

      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            idColumn: t.identity().primaryKey(),
            nameColumn: t.text(),
            ...t.foreignKey(['idColumn', 'nameColumn'], 'otherTable', [
              'foreignId',
              'foreignName',
            ]),
          })),
        () => {
          expectSql(`
            CREATE TABLE "table" (
              "id_column" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "name_column" text NOT NULL,
              ${toLine(`
                CONSTRAINT "table_id_column_name_column_fkey"
                  FOREIGN KEY ("id_column", "name_column")
                  REFERENCES "otherTable"("foreign_id", "foreign_name")
              `)}
            )
          `);
        },
      );
    });
  });

  describe('check', () => {
    it('should support database check on the column', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            columnWithCheck: t
              .text()
              .check(t.sql('length("columnWithCheck") > 10')),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              "columnWithCheck" text NOT NULL CHECK (length("columnWithCheck") > 10)
            )
          `),
      );
    });

    it('should support database check on the table', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            ...t.check(t.sql('sql')),
          })),
        () =>
          expectSql(`
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              CONSTRAINT "table_check" CHECK (sql)
            )
          `),
      );
    });
  });

  describe('constraint', () => {
    it('should support constraint', async () => {
      await testUpAndDown(
        (action) =>
          db[action]('table', (t) => ({
            id: t.identity().primaryKey(),
            ...t.constraint({
              name: 'constraintName',
              check: t.sql('sql'),
              references: [
                ['id'],
                'otherTable',
                ['otherId'],
                {
                  match: 'FULL',
                  onUpdate: 'CASCADE',
                  onDelete: 'CASCADE',
                },
              ],
            }),
          })),
        () =>
          expectSql(
            `
            CREATE TABLE "table" (
              "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              CONSTRAINT "constraintName" ` +
              `FOREIGN KEY ("id") REFERENCES "otherTable"("otherId") MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE ` +
              `CHECK (sql)
            )
          `,
          ),
      );
    });
  });

  it('should support column of custom type', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          id: t.identity().primaryKey(),
          column: t.type('customType'),
        })),
      () =>
        expectSql(`
          CREATE TABLE "table" (
            "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "column" "customType" NOT NULL
          )
        `),
    );
  });

  it('should support domain column', async () => {
    await testUpAndDown(
      (action) =>
        db[action]('table', (t) => ({
          id: t.identity().primaryKey(),
          domainColumn: t.domain('domainName'),
        })),
      () =>
        expectSql(`
          CREATE TABLE "table" (
            "id" int4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            "domainColumn" "domainName" NOT NULL
          )
        `),
    );
  });

  describe('noPrimaryKey', () => {
    const { warn } = console;
    afterAll(() => {
      db.options.noPrimaryKey = undefined;
      console.warn = warn;
    });

    it('should throw by default when no primary key', async () => {
      await testUpAndDown((action) =>
        expect(() => db[action]('table', () => ({}))).rejects.toThrow(
          'Table table has no primary key.\nYou can suppress this error by setting { noPrimaryKey: true } after a table name.',
        ),
      );
    });

    it('should throw when no primary key and noPrimaryKey is set to `error`', async () => {
      await testUpAndDown((action) => {
        db.options.noPrimaryKey = 'error';

        return expect(() => db[action]('table', () => ({}))).rejects.toThrow(
          'Table table has no primary key.\nYou can suppress this error by setting { noPrimaryKey: true } after a table name.',
        );
      });
    });

    it('should warn when no primary key and noPrimaryKey is set to `warning`', async () => {
      await testUpAndDown((action) => {
        console.warn = jest.fn();
        db.options.noPrimaryKey = 'warning';

        db[action]('table', () => ({}));

        expect(console.warn).toBeCalledWith(
          'Table table has no primary key.\nYou can suppress this error by setting { noPrimaryKey: true } after a table name.',
        );
      });
    });

    it('should not throw when no primary key and noPrimaryKey is set to `ignore`', async () => {
      await testUpAndDown((action) => {
        db.options.noPrimaryKey = 'ignore';

        expect(() => db[action]('table', () => ({}))).not.toThrow();
      });
    });

    it(`should not throw if option is set to \`true\` as a option`, async () => {
      await testUpAndDown((action) => {
        db.options.noPrimaryKey = 'error';

        expect(() =>
          db[action]('table', { noPrimaryKey: true }, () => ({})),
        ).not.toThrow();
      });
    });
  });
});
